<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <base href="/ui/" />
  <title>WineBot Dashboard</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b1114;
      --panel: #121a1f;
      --panel-2: #18232b;
      --accent: #4dd0a1;
      --accent-2: #5ec4ff;
      --text: #e6f0f4;
      --muted: #9fb3bf;
      --danger: #ff6b6b;
      --warn: #f7c96f;
      --ok: #4dd0a1;
      --border: #22303a;
      --shadow: rgba(0, 0, 0, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Space Grotesk", "Sora", "IBM Plex Sans", "Segoe UI", sans-serif;
      background: radial-gradient(1200px 700px at 10% 10%, #142028 0%, #0b1114 65%);
      color: var(--text);
    }

    #dashboard {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    #app {
      display: flex;
      flex: 1;
      min-height: 0;
    }

    #vnc-container {
      flex: 0 0 75%;
      min-width: 0;
      position: relative;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      background: linear-gradient(135deg, #0b1114 0%, #0f1a20 60%, #0c1419 100%);
      border-right: 1px solid var(--border);
      overflow: auto;
      pointer-events: auto;
      touch-action: none;
    }

    #vnc-container canvas {
      outline: none;
      width: auto !important;
      height: auto !important;
      max-width: none !important;
      max-height: none !important;
      display: block;
      pointer-events: auto;
    }

    #vnc-crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 100;
      display: none;
    }

    .vnc-overlay {
      position: absolute;
      top: 16px;
      left: 16px;
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 10px 14px;
      background: rgba(18, 26, 31, 0.78);
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: 0 8px 24px var(--shadow);
      backdrop-filter: blur(8px);
      z-index: 5;
      pointer-events: none;
    }

    .vnc-overlay-right {
      left: auto;
      right: 16px;
      text-align: right;
    }

    .vnc-overlay-right .badge {
      white-space: nowrap;
    }

    .vnc-title {
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    #control-panel {
      flex: 0 0 25%;
      min-width: 280px;
      padding: 24px 20px;
      background: var(--panel);
      display: flex;
      flex-direction: column;
      gap: 18px;
      overflow-y: auto;
    }

    .panel-header h1 {
      font-size: 1.4rem;
      margin: 0 0 6px;
    }

    .panel-header p {
      margin: 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .panel-section {
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 8px 18px var(--shadow);
    }

    .config-block {
      padding: 10px 0;
      border-bottom: 1px solid rgba(34, 48, 58, 0.6);
    }

    .config-block:last-of-type {
      border-bottom: 0;
      padding-bottom: 0;
    }

    .config-title {
      font-size: 0.85rem;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text);
    }

    .section-title {
      font-size: 0.95rem;
      font-weight: 600;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .section-toggle {
      border: 1px solid var(--border);
      background: transparent;
      color: var(--muted);
      font-size: 0.75rem;
      padding: 4px 8px;
      border-radius: 999px;
      cursor: pointer;
    }

    .section-toggle:hover {
      color: var(--text);
      border-color: rgba(94, 196, 255, 0.35);
    }

    .panel-section.collapsed .panel-body {
      display: none;
    }

    .panel-section.collapsed .section-toggle {
      transform: rotate(-90deg);
    }

    label {
      display: block;
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 6px;
    }

    input[type="password"],
    input[type="text"] {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #0d1418;
      color: var(--text);
      font-size: 0.9rem;
    }

    textarea {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #0d1418;
      color: var(--text);
      font-size: 0.82rem;
      font-family: "IBM Plex Mono", "JetBrains Mono", "SFMono-Regular", monospace;
      min-height: 120px;
      resize: vertical;
    }

    select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #0d1418;
      color: var(--text);
      font-size: 0.9rem;
    }

    button {
      border: 0;
      border-radius: 8px;
      padding: 8px 12px;
      font-weight: 600;
      background: var(--accent);
      color: #08110e;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease, opacity 120ms ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(77, 208, 161, 0.25);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    button.secondary {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--border);
    }

    button.warn {
      background: var(--warn);
      color: #1c1200;
    }

    button.danger {
      background: var(--danger);
      color: #1f0707;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .api-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
    }

    .api-row select {
      flex: 0 0 90px;
    }

    .api-row input {
      flex: 1;
    }

    .api-templates {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }

    .chip {
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 4px 10px;
      background: #0f171d;
      color: var(--muted);
      font-size: 0.72rem;
      cursor: pointer;
    }

    .code-block {
      margin-top: 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0d1418;
      padding: 10px;
      font-family: "IBM Plex Mono", "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 0.76rem;
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 220px;
      overflow: auto;
      color: var(--muted);
    }

    .code-block.ok {
      border-color: rgba(77, 208, 161, 0.35);
      color: var(--text);
    }

    .code-block.error {
      border-color: rgba(255, 107, 107, 0.4);
      color: var(--danger);
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .toggle input {
      accent-color: var(--accent);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #0f171d;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .badge.compact {
      padding: 4px 8px;
      font-size: 0.72rem;
      gap: 4px;
    }

    .badge.compact::before {
      content: "●";
      font-size: 0.55rem;
      line-height: 1;
      color: currentColor;
    }

    .badge-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      align-items: start;
    }

    .badge.ok {
      border-color: rgba(77, 208, 161, 0.4);
      color: var(--ok);
    }

    .badge.warn {
      border-color: rgba(247, 201, 111, 0.4);
      color: var(--warn);
    }

    .badge.error {
      border-color: rgba(255, 107, 107, 0.4);
      color: var(--danger);
    }

    .hint {
      margin-top: 6px;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .status-text {
      margin-top: 8px;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .events-list {
      margin-top: 10px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0f171d;
      max-height: 160px;
      overflow-y: auto;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .events-list div {
      margin-bottom: 6px;
    }

    .events-list div:last-child {
      margin-bottom: 0;
    }

    .hidden {
      display: none !important;
    }

    .session-ended {
      position: fixed;
      inset: 0;
      background: rgba(7, 10, 12, 0.92);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      padding: 24px;
    }

    .ended-card {
      width: min(520px, 90vw);
      background: #0f171d;
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: 0 24px 48px rgba(0, 0, 0, 0.45);
      padding: 22px;
      text-align: left;
    }

    .ended-card h2 {
      margin: 0 0 8px;
      font-size: 1.3rem;
    }

    .ended-card p {
      margin: 6px 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .ended-actions {
      margin-top: 14px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    #log-console {
      border-top: 1px solid var(--border);
      background: #0b1114;
      padding: 12px 18px 16px;
      min-height: 120px;
      max-height: 220px;
    }

    #log-console.collapsed {
      min-height: 0;
      max-height: 48px;
      padding-bottom: 10px;
    }

    #log-console.collapsed .log-entries {
      display: none;
    }

    #log-console.collapsed #log-toggle {
      transform: rotate(-90deg);
    }

    .log-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .log-actions {
      display: flex;
      gap: 8px;
    }

    .log-entries {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #0d1418;
      padding: 10px;
      height: clamp(110px, 18vh, 170px);
      overflow-y: auto;
      font-family: "IBM Plex Mono", "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .log-entry {
      display: grid;
      grid-template-columns: 90px 1fr;
      gap: 10px;
      margin-bottom: 6px;
    }

    .log-entry:last-child {
      margin-bottom: 0;
    }

    .log-entry .log-time {
      color: var(--muted);
      white-space: nowrap;
    }

    .log-entry.info .log-message {
      color: var(--text);
    }

    .log-entry.warn .log-message {
      color: var(--warn);
    }

    .log-entry.error .log-message {
      color: var(--danger);
    }

    .log-entry .log-message a {
      color: var(--accent-2);
      text-decoration: none;
    }

    @media (max-width: 980px) {
      #app {
        flex-direction: column;
      }

      #vnc-container,
      #control-panel {
        flex: 0 0 auto;
        width: 100%;
      }

      #vnc-container {
        min-height: 55vh;
      }

      #control-panel {
        max-height: 40vh;
      }

      .badge-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div id="dashboard">
    <div id="app">
      <section id="vnc-container">
        <canvas id="vnc-crosshair"></canvas>
        <div class="vnc-overlay">
          <div class="vnc-title">Live Session</div>
          <div id="badge-vnc" class="badge">connecting...</div>
        </div>
        <div class="vnc-overlay vnc-overlay-right">
          <div class="vnc-title">WineBot</div>
          <div class="badge" id="badge-version">Release v0.8.0-18-g48f5d13-dirty · Commit 48f5d13</div>
        </div>
      </section>

      <aside id="control-panel">
      <div class="panel-header">
        <h1>WineBot Dashboard</h1>
        <p>Control the session and check system health.</p>
      </div>

      <div class="panel-section" data-collapsible>
        <div class="section-title">
          <span>Configuration</span>
          <button class="section-toggle" type="button" aria-expanded="true">▾</button>
        </div>
        <div class="panel-body">
          <div class="config-block">
            <div class="config-title">API Access</div>
            <label for="api-token">API Token (optional)</label>
            <input id="api-token" type="password" placeholder="X-API-Key" />
            <div class="button-row" style="margin-top: 10px;">
              <button id="save-token" class="secondary">Save Token</button>
              <button id="clear-token" class="secondary">Clear</button>
            </div>
            <div class="hint">Stored in localStorage for this browser.</div>
          </div>
          <div class="config-block">
            <div class="config-title">VNC Access</div>
            <label for="vnc-host">VNC Host (optional)</label>
            <input id="vnc-host" type="text" placeholder="localhost" />
            <label for="vnc-port" style="margin-top: 8px;">VNC Port (optional)</label>
            <input id="vnc-port" type="text" placeholder="6080" />
            <label for="vnc-password" style="margin-top: 8px;">VNC Password</label>
            <input id="vnc-password" type="password" placeholder="VNC password" />
            <div class="button-row" style="margin-top: 10px;">
              <button id="save-vnc" class="secondary">Save Password</button>
              <button id="clear-vnc" class="secondary">Clear</button>
            </div>
            <div class="hint">Used only for the embedded noVNC session.</div>
          </div>
        </div>
      </div>

      <div class="panel-section" data-collapsible>
        <div class="section-title">
          <span>VNC Settings</span>
          <button class="section-toggle" type="button" aria-expanded="true">▾</button>
        </div>
        <div class="panel-body">
          <div class="config-block">
            <label class="toggle">
              <input type="checkbox" id="vnc-scale" />
              <span>Scale to Fit</span>
            </label>
            <div class="hint">Toggle between 1:1 mapping and scaled viewport.</div>
          </div>
          <div class="config-block">
            <label class="toggle">
              <input type="checkbox" id="vnc-view-only" />
              <span>View Only</span>
            </label>
          </div>
          <div class="config-block">
            <label class="toggle">
              <input type="checkbox" id="vnc-trace-input" />
              <span>Trace Input (client)</span>
            </label>
            <div class="hint">Log client-side mouse/key events to help diagnose input issues.</div>
          </div>
          <div class="button-row" style="margin-top: 10px;">
            <button id="btn-vnc-reconnect" class="secondary">Reconnect VNC</button>
            <button id="btn-force-focus" class="secondary">Force App Focus</button>
            <button id="btn-reset-workspace" class="secondary">Reset Workspace</button>
            <button id="btn-inject-click" class="secondary" disabled>Inject Last Click</button>
          </div>
        </div>
      </div>

      <div class="panel-section" data-collapsible>
        <div class="section-title">
          <span>Input Debug</span>
          <button class="section-toggle" type="button" aria-expanded="true">▾</button>
        </div>
        <div class="panel-body">
          <div id="input-debug-stats" class="status-text">Last event: none</div>
          <div id="input-debug-log" class="code-block" style="height: 100px;"></div>
        </div>
      </div>

      <div class="panel-section" data-collapsible>
        <div class="section-title">
          <span>Lifecycle</span>
          <button class="section-toggle" type="button" aria-expanded="true">▾</button>
        </div>
        <div class="panel-body">
          <div class="button-row">
            <button id="btn-shutdown" class="warn">Graceful Shutdown</button>
            <button id="btn-poweroff" class="danger">Power Off</button>
          </div>
          <div class="badge-grid">
            <span id="badge-xvfb" class="badge compact">Xvfb: pending</span>
            <span id="badge-openbox" class="badge compact">Openbox: pending</span>
            <span id="badge-vnc-process" class="badge compact">VNC: pending</span>
            <span id="badge-novnc" class="badge compact">noVNC: pending</span>
            <span id="badge-wine" class="badge compact">Wine: pending</span>
          </div>
        </div>
      </div>

      <div class="panel-section" data-collapsible>
        <div class="section-title">
          <span>Quick Actions</span>
          <button class="section-toggle" type="button" aria-expanded="true">▾</button>
        </div>
        <div class="panel-body">
          <div class="button-row">
            <button id="btn-screenshot">Capture Screenshot</button>
            <button id="btn-screenshot-download" class="secondary">Download Screenshot</button>
          </div>
          <div id="recording-panel" style="margin-top: 14px;">
            <div class="section-title">Recording</div>
          <div class="button-row">
            <button id="btn-record-start">Start</button>
            <button id="btn-record-pause" class="warn">Pause</button>
            <button id="btn-record-resume" class="secondary">Resume</button>
            <button id="btn-record-stop" class="danger">Stop</button>
          </div>
          </div>
          <div id="artifacts-panel" style="margin-top: 14px;">
            <div class="section-title">Recent Artifacts</div>
            <div id="artifacts-list" class="events-list">
              <div class="hint">No artifacts found yet.</div>
            </div>
          </div>
        </div>
      </div>

      <div class="panel-section" data-collapsible>
        <div class="section-title">
          <span>Health</span>
          <button class="section-toggle" type="button" aria-expanded="true">▾</button>
        </div>
        <div class="panel-body">
          <div class="badge-grid">
            <span id="badge-health" class="badge compact">/health: pending</span>
            <span id="badge-x11" class="badge compact">/health/x11: pending</span>
            <span id="badge-windows" class="badge compact">/health/windows: pending</span>
            <span id="badge-recording" class="badge compact">/health/recording: pending</span>
            <span id="badge-storage" class="badge compact">/health/storage: pending</span>
          </div>
        </div>
      </div>

      <div class="panel-section" data-collapsible>
        <div class="section-title">
          <span>API Console</span>
          <button class="section-toggle" type="button" aria-expanded="true">▾</button>
        </div>
        <div class="panel-body">
          <div class="api-row">
            <select id="api-method">
              <option value="GET">GET</option>
              <option value="POST">POST</option>
              <option value="PUT">PUT</option>
              <option value="DELETE">DELETE</option>
            </select>
            <input id="api-path" type="text" placeholder="/health" />
          </div>
          <label for="api-body">JSON Body (optional)</label>
          <textarea id="api-body" rows="6" placeholder='{"key":"value"}'></textarea>
          <div class="button-row" style="justify-content: space-between; align-items: center;">
            <div class="button-row">
              <button id="api-send">Send</button>
              <button id="api-send-force" class="secondary">Force Send</button>
            </div>
            <label class="toggle">
              <input type="checkbox" id="api-idempotent" checked />
              <span>Idempotent</span>
            </label>
          </div>
          <div class="api-templates">
            <button class="chip" data-api-template="health">/health</button>
            <button class="chip" data-api-template="sessions">/sessions</button>
            <button class="chip" data-api-template="suspend">Suspend session</button>
            <button class="chip" data-api-template="resume">Resume session</button>
            <button class="chip" data-api-template="record-start">Record start</button>
            <button class="chip" data-api-template="record-stop">Record stop</button>
            <button class="chip" data-api-template="lifecycle">/lifecycle/status</button>
            <button class="chip" data-api-template="shutdown">Shutdown</button>
            <button class="chip" data-api-template="windows">/windows</button>
            <button class="chip" data-api-template="apps">/apps</button>
            <button class="chip" data-api-template="inspect">Inspect window</button>
          </div>
          <div id="api-response" class="code-block">Response: waiting…</div>
        </div>
      </div>
      </aside>
    </div>

    <div id="log-console">
      <div class="log-header">
        <div>Activity Log</div>
        <div class="log-actions">
          <button id="log-toggle" class="section-toggle" type="button" aria-expanded="true">▾</button>
          <button id="log-clear" class="secondary">Clear</button>
        </div>
      </div>
      <div id="log-entries" class="log-entries"></div>
    </div>
  </div>

  <div id="session-ended" class="session-ended hidden">
    <div class="ended-card">
      <h2>WineBot disconnected</h2>
      <p id="ended-reason">The WineBot API or live session is unreachable.</p>
      <p id="ended-detail">This dashboard will keep polling to reconnect to the current WineBot session.</p>
      <div class="ended-actions">
        <button id="btn-resume" class="secondary">Continue polling</button>
        <button id="btn-close-tab" class="danger">Close tab</button>
      </div>
    </div>
  </div>

  <script type="module">
    const vncContainer = document.getElementById("vnc-container");
    const badgeVnc = document.getElementById("badge-vnc");
    const badgeXvfb = document.getElementById("badge-xvfb");
    const badgeOpenbox = document.getElementById("badge-openbox");
    const badgeVncProcess = document.getElementById("badge-vnc-process");
    const badgeNoVnc = document.getElementById("badge-novnc");
    const badgeWine = document.getElementById("badge-wine");
    const badgeHealth = document.getElementById("badge-health");
    const badgeX11 = document.getElementById("badge-x11");
    const badgeWindows = document.getElementById("badge-windows");
    const badgeRecording = document.getElementById("badge-recording");
    const badgeStorage = document.getElementById("badge-storage");

    const tokenInput = document.getElementById("api-token");
    const saveTokenBtn = document.getElementById("save-token");
    const clearTokenBtn = document.getElementById("clear-token");
    const vncHostInput = document.getElementById("vnc-host");
    const vncPortInput = document.getElementById("vnc-port");
    const vncPasswordInput = document.getElementById("vnc-password");
    const saveVncBtn = document.getElementById("save-vnc");
    const clearVncBtn = document.getElementById("clear-vnc");

    const vncScaleToggle = document.getElementById("vnc-scale");
    const vncViewOnlyToggle = document.getElementById("vnc-view-only");
    const vncTraceToggle = document.getElementById("vnc-trace-input");
    const vncReconnectBtn = document.getElementById("btn-vnc-reconnect");
    const vncForceFocusBtn = document.getElementById("btn-force-focus");
    const vncInjectBtn = document.getElementById("btn-inject-click");
    const inputDebugStats = document.getElementById("input-debug-stats");
    const inputDebugLog = document.getElementById("input-debug-log");
    const vncCrosshair = document.getElementById("vnc-crosshair");
    let crosshairCtx = null;

    if (vncCrosshair) {
        crosshairCtx = vncCrosshair.getContext("2d");
    }

    function updateCrosshair(x, y, visible) {
        if (!vncCrosshair || !crosshairCtx) return;
        if (!visible) {
            vncCrosshair.style.display = "none";
            return;
        }
        
        // Sync size with VNC canvas if possible
        const vncCanvas = vncContainer.querySelector("canvas:not(#vnc-crosshair)");
        if (vncCanvas) {
            if (vncCrosshair.width !== vncCanvas.width || vncCrosshair.height !== vncCanvas.height) {
                vncCrosshair.width = vncCanvas.width;
                vncCrosshair.height = vncCanvas.height;
                // Match VNC canvas style size
                vncCrosshair.style.width = vncCanvas.style.width;
                vncCrosshair.style.height = vncCanvas.style.height;
            }
        } else {
             // Fallback
             vncCrosshair.width = 1920; 
             vncCrosshair.height = 1080;
        }

        vncCrosshair.style.display = "block";
        const ctx = crosshairCtx;
        const w = vncCrosshair.width;
        const h = vncCrosshair.height;

        ctx.clearRect(0, 0, w, h);
        ctx.beginPath();
        ctx.strokeStyle = "rgba(255, 0, 0, 0.8)";
        ctx.lineWidth = 2;
        
        // Vertical line
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        
        // Horizontal line
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        
        ctx.stroke();
        
        // Circle at intersection
        ctx.beginPath();
        ctx.strokeStyle = "rgba(255, 255, 0, 0.9)";
        ctx.arc(x, y, 5, 0, 2 * Math.PI);
        ctx.stroke();
    }

    let lastVncClick = null;

    function updateInputDebug(msg) {
      inputDebugStats.textContent = `Last event: ${msg}`;
      const div = document.createElement("div");
      div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      inputDebugLog.prepend(div);
      if (inputDebugLog.childNodes.length > 20) {
        inputDebugLog.lastChild.remove();
      }
    }

    async function forceAppFocus() {
      updateInputDebug("Requesting app focus...");
      try {
        const res = await apiFetch("/health/windows");
        const data = await res.json();
        const windows = data.windows || [];
        // Look for typical apps
        const target = windows.find(w => /notepad|regedit|winefile/i.test(w.title));
        if (target) {
          logMessage("info", `Targeting window for focus: ${target.title} (${target.id})`);
          await apiFetch("/inspect/window", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ window_id: target.id, focus: true })
          });
          updateInputDebug(`Focused ${target.title}`);
        } else {
          logMessage("warn", "No known automation window found to focus.");
          updateInputDebug("No target window found");
        }
      } catch (err) {
        logMessage("error", `Focus error: ${err.message}`);
      }
    }

    const screenshotBtn = document.getElementById("btn-screenshot");
    const screenshotDownloadBtn = document.getElementById("btn-screenshot-download");

    const recordStartBtn = document.getElementById("btn-record-start");
    const recordPauseBtn = document.getElementById("btn-record-pause");
    const recordResumeBtn = document.getElementById("btn-record-resume");
    const recordStopBtn = document.getElementById("btn-record-stop");
    const recordingPanel = document.getElementById("recording-panel");
    const artifactsList = document.getElementById("artifacts-list");
    const apiMethodSelect = document.getElementById("api-method");
    const apiPathInput = document.getElementById("api-path");
    const apiBodyInput = document.getElementById("api-body");
    const apiSendBtn = document.getElementById("api-send");
    const apiSendForceBtn = document.getElementById("api-send-force");
    const apiIdempotentToggle = document.getElementById("api-idempotent");
    const apiResponse = document.getElementById("api-response");
    const apiTemplateButtons = document.querySelectorAll("[data-api-template]");
    const shutdownBtn = document.getElementById("btn-shutdown");
    const powerOffBtn = document.getElementById("btn-poweroff");
    const sessionEndedOverlay = document.getElementById("session-ended");
    const endedReason = document.getElementById("ended-reason");
    const endedDetail = document.getElementById("ended-detail");
    const resumePollingBtn = document.getElementById("btn-resume");
    const closeTabBtn = document.getElementById("btn-close-tab");
    const logConsole = document.getElementById("log-console");
    const logToggleBtn = document.getElementById("log-toggle");
    const logEntries = document.getElementById("log-entries");
    const logClearBtn = document.getElementById("log-clear");

    const API_TOKEN_KEY = "winebot_api_token";
    const VNC_PASSWORD_KEY = "winebot_vnc_password";
    const VNC_HOST_KEY = "winebot_vnc_host";
    const VNC_PORT_KEY = "winebot_vnc_port";
    let rfbInstance = null;
    let vncNeedsCredentials = false;
    let vncConnected = false;
    let vncTraceEnabled = false;
    let vncTraceCanvas = null;
    let vncTraceLastMoveTs = 0;
    let vncKeyListenersAttached = false;
    let pollTimer = null;
    let pollStopped = false;
    let pollMode = "normal";
    let pollFailureStreak = 0;
    let backoffIndex = 0;
    let backoffElapsedMs = 0;
    const BASE_BACKOFF_MS = 5000;
    const MAX_BACKOFF_MS = 180000;
    const MAX_BACKOFF_DELAY_MS = 60000;
    let sessionEndedReason = null;
    let nextPollAt = 0;
    let countdownTimer = null;
    let lastBackoffReason = null;
    const loggedEvents = new Set();
    const statusSnapshot = {
      sessionId: null,
      recordingState: null,
      recordingEnabled: null
    };

    function getToken() {
      return localStorage.getItem(API_TOKEN_KEY) || "";
    }

    function setToken(value) {
      if (value) {
        localStorage.setItem(API_TOKEN_KEY, value);
      } else {
        localStorage.removeItem(API_TOKEN_KEY);
      }
    }

    function getVncHost() {
      return localStorage.getItem(VNC_HOST_KEY) || "";
    }

    function setVncHost(value) {
      if (value) {
        localStorage.setItem(VNC_HOST_KEY, value);
      } else {
        localStorage.removeItem(VNC_HOST_KEY);
      }
    }

    function getVncPort() {
      return localStorage.getItem(VNC_PORT_KEY) || "";
    }

    function setVncPort(value) {
      if (value) {
        localStorage.setItem(VNC_PORT_KEY, value);
      } else {
        localStorage.removeItem(VNC_PORT_KEY);
      }
    }

    function getVncPassword() {
      return localStorage.getItem(VNC_PASSWORD_KEY) || "";
    }

    function setVncPassword(value) {
      if (value) {
        localStorage.setItem(VNC_PASSWORD_KEY, value);
      } else {
        localStorage.removeItem(VNC_PASSWORD_KEY);
      }
    }

    function canTraceClientEvent() {
      return vncTraceEnabled && vncConnected && vncTraceCanvas;
    }

    function getCanvasCoords(canvas, e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.clientX - rect.left;
      const clientY = e.clientY - rect.top;
      const scaleX = rect.width ? (canvas.width / rect.width) : 0;
      const scaleY = rect.height ? (canvas.height / rect.height) : 0;
      const vncX = Math.floor(clientX * scaleX);
      const vncY = Math.floor(clientY * scaleY);
      return {
        client_x: Math.round(clientX),
        client_y: Math.round(clientY),
        vnc_x: vncX,
        vnc_y: vncY,
        canvas_width: canvas.width,
        canvas_height: canvas.height,
        client_width: Math.round(rect.width),
        client_height: Math.round(rect.height),
        scale_x: scaleX ? Number(scaleX.toFixed(4)) : 0,
        scale_y: scaleY ? Number(scaleY.toFixed(4)) : 0
      };
    }

    async function postClientTraceEvent(payload) {
      if (!canTraceClientEvent()) {
        return;
      }
      try {
        payload.origin = payload.origin || "user";
        payload.tool = payload.tool || "novnc-ui";
        payload.layer = payload.layer || "client";
        await apiFetch("/input/client/event", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
      } catch (err) {}
    }

    async function refreshClientTraceStatus() {
      try {
        const res = await apiFetch("/input/trace/client/status");
        if (!res || !res.ok) {
          return;
        }
        const data = await safeJson(res);
        const enabled = Boolean(data && data.enabled);
        vncTraceEnabled = enabled;
        vncTraceToggle.checked = enabled;
      } catch (err) {}
    }

    async function setClientTraceEnabled(enabled) {
      try {
        const path = enabled ? "/input/trace/client/start" : "/input/trace/client/stop";
        const res = await apiFetch(path, { method: "POST" });
        if (res && res.ok) {
          vncTraceEnabled = enabled;
          vncTraceToggle.checked = enabled;
        }
      } catch (err) {}
    }

    function attachVncKeyListeners() {
      if (vncKeyListenersAttached) {
        return;
      }
      vncKeyListenersAttached = true;
      window.addEventListener("keydown", (e) => {
        if (!canTraceClientEvent()) return;
        if (document.activeElement && vncTraceCanvas && document.activeElement !== vncTraceCanvas) {
          return;
        }
        postClientTraceEvent({
          event: "client_key_down",
          key: e.key,
          code: e.code,
          key_code: e.keyCode,
          repeat: e.repeat,
          ctrl: e.ctrlKey,
          alt: e.altKey,
          shift: e.shiftKey,
          meta: e.metaKey
        });
      }, true);
      window.addEventListener("keyup", (e) => {
        if (!canTraceClientEvent()) return;
        if (document.activeElement && vncTraceCanvas && document.activeElement !== vncTraceCanvas) {
          return;
        }
        postClientTraceEvent({
          event: "client_key_up",
          key: e.key,
          code: e.code,
          key_code: e.keyCode,
          ctrl: e.ctrlKey,
          alt: e.altKey,
          shift: e.shiftKey,
          meta: e.metaKey
        });
      }, true);
    }


    function resetVncCanvas() {
      const canvases = vncContainer.querySelectorAll("canvas");
      canvases.forEach((canvas) => canvas.remove());
      vncTraceCanvas = null;
    }

    function setBadge(element, text, state) {
      element.textContent = text;
      element.classList.remove("ok", "warn", "error");
      if (state) {
        element.classList.add(state);
      }
    }

    function setProcessBadge(element, label, running) {
      const status = running ? "running" : "down";
      setBadge(element, `${label}: ${status}`, running ? "ok" : "error");
    }

    function logMessage(level, message, options = {}) {
      if (!logEntries) {
        return;
      }
      const entry = document.createElement("div");
      entry.classList.add("log-entry", level || "info");
      const time = document.createElement("div");
      time.classList.add("log-time");
      time.textContent = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
      const msg = document.createElement("div");
      msg.classList.add("log-message");
      msg.textContent = message;
      if (options.link && options.linkLabel) {
        const space = document.createTextNode(" ");
        const anchor = document.createElement("a");
        anchor.href = options.link;
        anchor.textContent = options.linkLabel;
        anchor.target = "_blank";
        if (options.downloadName) {
          anchor.download = options.downloadName;
        }
        msg.appendChild(space);
        msg.appendChild(anchor);
      }
      entry.appendChild(time);
      entry.appendChild(msg);
      logEntries.appendChild(entry);
      logEntries.scrollTop = logEntries.scrollHeight;
    }

    function logLifecycleEvents(events) {
      if (!Array.isArray(events)) {
        return;
      }
      events.forEach((event) => {
        const key = `${event.timestamp_utc}|${event.kind}|${event.message}`;
        if (loggedEvents.has(key)) {
          return;
        }
        loggedEvents.add(key);
        const kind = event.kind || "event";
        const message = event.message || "";
        const level = /fail|error|failed/i.test(kind) ? "error" : /warn|stop_failed/i.test(kind) ? "warn" : "info";
        logMessage(level, `${kind} ${message}`.trim());
      });
    }

    function showSessionEnded(reasonKey, reasonText, detailText) {
      sessionEndedReason = reasonKey;
      if (reasonKey === "vnc") {
        endedReason.textContent = "Live session disconnected.";
        endedDetail.textContent = "WineBot is running; waiting for the live session to reconnect.";
      } else if (reasonKey === "api") {
        endedReason.textContent = "WineBot API disconnected.";
        endedDetail.textContent = "Polling for the WineBot session to return (same container or after restart).";
      } else if (reasonKey === "poweroff") {
        endedReason.textContent = "WineBot powered off.";
        endedDetail.textContent = "Polling is stopped. Start WineBot again to reconnect.";
      } else {
        endedReason.textContent = reasonText || "WineBot disconnected.";
        endedDetail.textContent = detailText || "See the activity log for details.";
      }
      sessionEndedOverlay.classList.remove("hidden");
    }

    function hideSessionEnded() {
      sessionEndedReason = null;
      sessionEndedOverlay.classList.add("hidden");
    }

    function setResumeState(enabled, label) {
      resumePollingBtn.disabled = !enabled;
      resumePollingBtn.textContent = label || (enabled ? "Continue polling" : "Polling stopped");
    }

    function enterBackoff(reasonKey, reasonText, detailText) {
      const switchingReason = sessionEndedReason && sessionEndedReason !== reasonKey;
      if (pollMode !== "backoff" || switchingReason) {
        backoffIndex = 0;
        backoffElapsedMs = 0;
      }
      pollMode = "backoff";
      if (!sessionEndedReason || sessionEndedReason !== reasonKey) {
        showSessionEnded(reasonKey, reasonText, detailText);
      }
      if (reasonKey !== "poweroff") {
        setResumeState(true, "Continue polling");
      }
      if (lastBackoffReason !== reasonKey || switchingReason) {
        logMessage("warn", `${reasonText} ${detailText}`.trim());
        lastBackoffReason = reasonKey;
      }
    }

    function exitBackoff(reasonKey) {
      if (sessionEndedReason === reasonKey) {
        hideSessionEnded();
      }
      logMessage("info", reasonKey === "vnc" ? "Live session reconnected." : "API connection restored.");
      pollMode = "normal";
      pollFailureStreak = 0;
      backoffIndex = 0;
      backoffElapsedMs = 0;
      pollStopped = false;
      stopCountdown();
    }

    function nextPollDelay() {
      if (pollMode === "backoff") {
        const delay = Math.min(MAX_BACKOFF_DELAY_MS, BASE_BACKOFF_MS * (2 ** backoffIndex));
        if (backoffElapsedMs + delay >= MAX_BACKOFF_MS) {
          pollStopped = true;
          logMessage("warn", "Polling stopped after repeated reconnect attempts.");
          return null;
        }
        backoffIndex += 1;
        backoffElapsedMs += delay;
        return delay;
      }
      return 5000;
    }

    function stopCountdown() {
      if (countdownTimer) {
        clearInterval(countdownTimer);
        countdownTimer = null;
      }
    }

    function stopPolling(reasonText, detailText) {
      pollStopped = true;
      if (pollTimer) {
        clearTimeout(pollTimer);
        pollTimer = null;
      }
      stopCountdown();
      showSessionEnded("poweroff", reasonText, detailText);
      logMessage("error", `${reasonText} ${detailText}`.trim());
      setResumeState(false, "Polling stopped");
    }

    function attemptCloseTab() {
      window.close();
      setTimeout(() => {
        if (!window.closed) {
          logMessage("warn", "Tab could not be closed automatically. Please close it manually.");
        }
      }, 300);
    }

    function startCountdown() {
      stopCountdown();
    }

    function scheduleNextPoll(delay) {
      if (pollTimer) {
        clearTimeout(pollTimer);
      }
      if (delay === null) {
        stopCountdown();
        return;
      }
      nextPollAt = Date.now() + delay;
      if (pollMode === "backoff") {
        startCountdown();
      } else {
        stopCountdown();
      }
      pollTimer = setTimeout(runPoll, delay);
    }

    async function runPoll() {
      await updateDashboard();
      if (pollStopped) {
        return;
      }
      scheduleNextPoll(nextPollDelay());
    }

    async function apiFetch(path, options = {}) {
      const headers = new Headers(options.headers || {});
      const token = getToken();
      if (token) {
        headers.set("X-API-Key", token);
      }
      return fetch(path, { ...options, headers });
    }

    async function updateArtifacts(activeSessionId) {
      if (!artifactsList) return;
      
      try {
        // 1. Get list of all sessions to find recent history
        const sessionsRes = await apiFetch("/sessions?limit=3");
        let targetSessions = [];
        if (sessionsRes.ok) {
            const sessionsData = await sessionsRes.json();
            targetSessions = sessionsData.sessions || [];
        }
        
        // If we have an active session, ensure it's in the list
        if (activeSessionId && !targetSessions.find(s => s.session_id === activeSessionId)) {
            targetSessions.unshift({ session_id: activeSessionId });
        }

        if (targetSessions.length === 0) {
          artifactsList.innerHTML = '<div class="hint">No artifacts found yet.</div>';
          return;
        }

        // 2. Fetch artifacts from the most recent sessions (limit to top 1 for performance, or aggregate)
        // For simplicity/performance, we focus on the MOST RECENT session (active or not)
        const primarySession = targetSessions[0]; 
        const res = await apiFetch(`/sessions/${primarySession.session_id}/artifacts`);
        if (!res.ok) return;
        
        const data = await res.json();
        const files = data.artifacts || [];
        
        const filtered = files.filter(f => 
          f.path.endsWith(".mkv") || 
          f.path.endsWith(".png") || 
          f.path.endsWith(".jsonl") || 
          f.path.endsWith(".log")
        ).sort((a, b) => b.mtime - a.mtime);

        artifactsList.innerHTML = "";
        
        // Header
        const header = document.createElement("div");
        header.className = "hint";
        header.textContent = `Session: ${primarySession.session_id}`;
        header.style.borderBottom = "1px solid var(--border)";
        header.style.paddingBottom = "4px";
        header.style.marginBottom = "6px";
        artifactsList.appendChild(header);

        if (filtered.length === 0) {
             const div = document.createElement("div");
             div.textContent = "No files yet.";
             div.style.fontSize = "0.75rem";
             artifactsList.appendChild(div);
        }

        filtered.forEach(f => {
          const div = document.createElement("div");
          div.style.display = "flex";
          div.style.justify_content = "space-between";
          div.style.gap = "8px";
          div.style.marginBottom = "4px";

          const link = document.createElement("a");
          link.href = `/sessions/${primarySession.session_id}/artifacts/${f.path}`;
          link.textContent = f.path;
          link.target = "_blank";
          link.style.color = "var(--accent-2)";
          link.style.textDecoration = "none";
          link.style.fontSize = "0.75rem";
          
          const size = document.createElement("span");
          size.textContent = `(${(f.size / 1024 / 1024).toFixed(1)} MB)`;
          size.style.fontSize = "0.7rem";
          size.style.color = "var(--muted)";

          div.appendChild(link);
          div.appendChild(size);
          artifactsList.appendChild(div);
        });
      } catch (err) {}
    }

    async function updateDashboard() {
      if (!versionLoaded) updateVersion();
      try {
        const results = await Promise.allSettled([
          apiFetch("/health"),
          apiFetch("/health/x11"),
          apiFetch("/health/windows"),
          apiFetch("/health/recording"),
          apiFetch("/health/storage"),
          apiFetch("/lifecycle/status"),
          apiFetch("/lifecycle/events?limit=6"),
          apiFetch("/input/trace/client/status")
        ]);

        const [healthRes, x11Res, windowsRes, recordingRes, storageRes, lifecycleRes, eventsRes, clientTraceRes] =
          results.map((result) => (result.status === "fulfilled" ? result.value : null));

        const healthData = healthRes ? await safeJson(healthRes) : null;
        const lifecycleData = lifecycleRes ? await safeJson(lifecycleRes) : null;
        
        // Fetch control state if session is active
        let controlState = null;
        if (lifecycleData && lifecycleData.session_id) {
             try {
                 const ctrlRes = await apiFetch(`/sessions/${lifecycleData.session_id}/control`);
                 if (ctrlRes.ok) {
                     controlState = await safeJson(ctrlRes);
                 }
             } catch (e) {}
        }
        
        // Update Crosshair if in Agent mode
        if (controlState && controlState.control_mode === "AGENT") {
             try {
                 // Get last agent input event
                 const inputRes = await apiFetch("/input/events?limit=1&origin=agent");
                 if (inputRes.ok) {
                     const inputData = await safeJson(inputRes);
                     if (inputData.events && inputData.events.length > 0) {
                         const ev = inputData.events[0];
                         if (ev.x !== undefined && ev.y !== undefined) {
                             updateCrosshair(ev.x, ev.y, true);
                         }
                     }
                 }
             } catch (e) {}
        } else {
             updateCrosshair(0, 0, false);
        }

        const x11Data = x11Res ? await safeJson(x11Res) : null;
        const windowsData = windowsRes ? await safeJson(windowsRes) : null;
        const recordingData = recordingRes ? await safeJson(recordingRes) : null;
        const storageData = storageRes ? await safeJson(storageRes) : null;
        const lifecycleData = lifecycleRes ? await safeJson(lifecycleRes) : null;
        const eventsData = eventsRes ? await safeJson(eventsRes) : null;
        const clientTraceData = clientTraceRes ? await safeJson(clientTraceRes) : null;

        const apiForbidden = Boolean(healthRes && healthRes.status === 403);
        const apiHealthy = Boolean(healthRes && healthRes.ok && healthData);
        if (apiHealthy) {
          setBadge(badgeHealth, `/health: ${healthData.status}`, healthData.status === "ok" ? "ok" : "warn");
        } else if (healthRes) {
          const label = healthRes.status === 403 ? "auth required" : healthRes.status;
          setBadge(badgeHealth, `/health: ${label}`, healthRes.status === 403 ? "warn" : "error");
        } else {
          setBadge(badgeHealth, `/health: error`, "error");
        }

        if (!apiHealthy && !apiForbidden) {
          pollFailureStreak += 1;
          if (pollFailureStreak >= 2) {
            enterBackoff("api", "WineBot API disconnected", "API is unreachable. Polling for the WineBot session to return.");
          }
        } else if (apiHealthy && pollFailureStreak > 0) {
          pollFailureStreak = 0;
          if (sessionEndedReason === "api") {
            if (!vncConnected) {
              enterBackoff("vnc", "Live session reconnecting", "WineBot API is back. Waiting for the live session to reconnect.");
              restartVnc();
            } else {
              exitBackoff("api");
            }
          } else {
            exitBackoff("api");
          }
        }

        if (x11Res && x11Res.ok && x11Data) {
          const data = x11Data;
          setBadge(badgeX11, `/health/x11: ${data.connected ? "connected" : "down"}`, data.connected ? "ok" : "error");
        } else if (x11Res) {
          const label = x11Res.status === 403 ? "auth required" : x11Res.status;
          setBadge(badgeX11, `/health/x11: ${label}`, x11Res.status === 403 ? "warn" : "error");
        } else {
          setBadge(badgeX11, `/health/x11: error`, "error");
        }

        if (windowsRes && windowsRes.ok && windowsData) {
          const data = windowsData;
          setBadge(badgeWindows, `/health/windows: ${data.count} windows`, data.count > 0 ? "ok" : "warn");
        } else if (windowsRes) {
          const label = windowsRes.status === 403 ? "auth required" : windowsRes.status;
          setBadge(badgeWindows, `/health/windows: ${label}`, windowsRes.status === 403 ? "warn" : "error");
        } else {
          setBadge(badgeWindows, `/health/windows: error`, "error");
        }

        if (recordingRes && recordingRes.ok && recordingData) {
          const data = recordingData;
          const running = data.recorder_running === true;
          const state = data.state || (running ? "recording" : "idle");
          setBadge(badgeRecording, `/health/recording: ${state}`, running ? "ok" : "warn");
          const enabled = data.enabled !== false;
          recordingPanel.style.display = enabled ? "" : "none";
          if (statusSnapshot.recordingEnabled !== enabled) {
            logMessage("info", `Recording ${enabled ? "enabled" : "disabled"}.`);
          }
          statusSnapshot.recordingEnabled = enabled;
          if (statusSnapshot.recordingState !== state) {
            logMessage("info", `Recording state: ${state}.`);
          }
          statusSnapshot.recordingState = state;
          if (!enabled) {
            recordStartBtn.disabled = true;
            recordPauseBtn.disabled = true;
            recordResumeBtn.disabled = true;
            recordStopBtn.disabled = true;
            // Recording disabled; keep updating the rest of the dashboard.
          }
          recordStartBtn.disabled = running;
          recordStopBtn.disabled = !running;
          if (state === "paused") {
            recordPauseBtn.disabled = true;
            recordResumeBtn.disabled = false;
          } else {
            recordPauseBtn.disabled = !running;
            recordResumeBtn.disabled = true;
          }
        } else if (recordingRes) {
          const label = recordingRes.status === 403 ? "auth required" : recordingRes.status;
          setBadge(badgeRecording, `/health/recording: ${label}`, recordingRes.status === 403 ? "warn" : "error");
          recordStartBtn.disabled = false;
          recordPauseBtn.disabled = true;
          recordResumeBtn.disabled = true;
          recordStopBtn.disabled = true;
        } else {
          setBadge(badgeRecording, `/health/recording: error`, "error");
        }

        if (clientTraceRes && clientTraceRes.ok && clientTraceData) {
          const enabled = Boolean(clientTraceData.enabled);
          if (vncTraceEnabled !== enabled) {
            vncTraceEnabled = enabled;
            vncTraceToggle.checked = enabled;
          }
        }

        if (storageRes && storageRes.ok && storageData) {
          const data = storageData;
          setBadge(badgeStorage, `/health/storage: ${data.ok ? "ok" : "check"}`, data.ok ? "ok" : "warn");
        } else if (storageRes) {
          const label = storageRes.status === 403 ? "auth required" : storageRes.status;
          setBadge(badgeStorage, `/health/storage: ${label}`, storageRes.status === 403 ? "warn" : "error");
        } else {
          setBadge(badgeStorage, `/health/storage: error`, "error");
        }

        if (lifecycleRes && lifecycleRes.ok && lifecycleData) {
          const data = lifecycleData;
          if (data.session_id) {
            const session = data.session_id;
            const userDir = data.user_dir || "unknown user dir";
            if (statusSnapshot.sessionId !== session) {
              logMessage("info", `Session active: ${session} (user: ${userDir}).`);
              statusSnapshot.sessionId = session;
            }
          } else if (statusSnapshot.sessionId) {
            logMessage("warn", "Session id not reported by lifecycle status.");
            statusSnapshot.sessionId = null;
          }
          const processes = data.processes || {};
          setProcessBadge(badgeXvfb, "Xvfb", processes.xvfb?.ok === true);
          setProcessBadge(badgeOpenbox, "Openbox", processes.openbox?.ok === true);
          setProcessBadge(badgeVncProcess, "VNC", processes.x11vnc?.ok === true);
          setProcessBadge(badgeNoVnc, "noVNC", processes.novnc?.ok === true);
          setProcessBadge(badgeWine, "Wine", processes.wine_explorer?.ok === true);
          shutdownBtn.disabled = false;
          powerOffBtn.disabled = false;
          
          if (lifecycleData.session_id) {
            updateArtifacts(lifecycleData.session_id);
          }
        } else if (lifecycleRes) {
          const label = lifecycleRes.status === 403 ? "auth required" : lifecycleRes.status;
          setBadge(badgeXvfb, "Xvfb: unknown", "warn");
          setBadge(badgeOpenbox, "Openbox: unknown", "warn");
          setBadge(badgeVncProcess, "VNC: unknown", "warn");
          setBadge(badgeNoVnc, "noVNC: unknown", "warn");
          setBadge(badgeWine, "Wine: unknown", "warn");
          shutdownBtn.disabled = lifecycleRes.status === 403;
          powerOffBtn.disabled = lifecycleRes.status === 403;
        } else {
          setBadge(badgeXvfb, "Xvfb: error", "error");
          setBadge(badgeOpenbox, "Openbox: error", "error");
          setBadge(badgeVncProcess, "VNC: error", "error");
          setBadge(badgeNoVnc, "noVNC: error", "error");
          setBadge(badgeWine, "Wine: error", "error");
          shutdownBtn.disabled = true;
          powerOffBtn.disabled = true;
        }

        if (eventsRes && eventsRes.ok && eventsData) {
          logLifecycleEvents(eventsData.events || []);
        }
      } catch (err) {
        setBadge(badgeHealth, "/health: error", "error");
        pollFailureStreak += 1;
        if (pollFailureStreak >= 2) {
          enterBackoff("api", "WineBot API disconnected", "API is unreachable. Polling for the WineBot session to return.");
        }
      }
    }

    async function safeJson(response) {
      try {
        return await response.json();
      } catch (err) {
        return null;
      }
    }

    const API_CONSOLE_CACHE_KEY = "winebot_api_console_cache";

    function getApiConsoleCache() {
      try {
        const raw = sessionStorage.getItem(API_CONSOLE_CACHE_KEY);
        return raw ? JSON.parse(raw) : {};
      } catch (err) {
        return {};
      }
    }

    function setApiConsoleCache(cache) {
      try {
        sessionStorage.setItem(API_CONSOLE_CACHE_KEY, JSON.stringify(cache));
      } catch (err) {
        // Ignore cache write failures.
      }
    }

    function apiConsoleKey(method, path, body) {
      return `${method}::${path}::${body || ""}`;
    }

    function renderApiResponse(payload, cached) {
      const status = payload.status ?? "unknown";
      const ok = Boolean(payload.ok);
      const origin = cached ? "cached" : "live";
      apiResponse.classList.remove("ok", "error");
      apiResponse.classList.add(ok ? "ok" : "error");
      apiResponse.textContent = `[${status}] ${ok ? "OK" : "ERROR"} (${origin})\n${payload.body || ""}`.trim();
    }

    async function sendApiConsole(force = false) {
      const method = apiMethodSelect.value;
      let path = apiPathInput.value.trim();
      const body = apiBodyInput.value.trim();
      if (!path) {
        apiResponse.textContent = "Response: enter a path to send.";
        apiResponse.classList.remove("ok", "error");
        return;
      }
      if (!path.startsWith("/")) {
        path = `/${path}`;
      }

      const key = apiConsoleKey(method, path, body);
      if (apiIdempotentToggle.checked && !force) {
        const cache = getApiConsoleCache();
        if (cache[key]) {
          renderApiResponse(cache[key], true);
          return;
        }
      }

      apiResponse.classList.remove("ok", "error");
      apiResponse.textContent = "Sending request...";
      try {
        const options = { method };
        if (body && method !== "GET") {
          options.headers = { "Content-Type": "application/json" };
          options.body = body;
        }
        const response = await apiFetch(path, options);
        const contentType = response.headers.get("content-type") || "";
        let payloadText = "";
        if (contentType.includes("application/json")) {
          const data = await safeJson(response);
          payloadText = data ? JSON.stringify(data, null, 2) : "";
        } else if (contentType.startsWith("text/") || contentType === "") {
          payloadText = await response.text();
        } else {
          payloadText = `Binary response (${contentType || "unknown"})`;
        }
        const payload = { status: response.status, ok: response.ok, body: payloadText };
        renderApiResponse(payload, false);
        if (apiIdempotentToggle.checked && response.ok && !force) {
          const cache = getApiConsoleCache();
          cache[key] = payload;
          setApiConsoleCache(cache);
        }
      } catch (err) {
        apiResponse.classList.remove("ok");
        apiResponse.classList.add("error");
        apiResponse.textContent = `API console error: ${err.message}`;
      }
    }

    async function takeScreenshot({ download } = { download: false }) {
      logMessage("info", download ? "Capturing screenshot for download..." : "Capturing screenshot...");
      try {
        const response = await apiFetch("/screenshot");
        if (!response.ok) {
          throw new Error(`Screenshot failed: ${response.status}`);
        }
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        const savedPath = response.headers.get("X-Screenshot-Path");
        const metaPath = response.headers.get("X-Screenshot-Metadata-Path");
        const message = savedPath
          ? `Screenshot saved in session: ${savedPath}${metaPath ? ` (metadata: ${metaPath})` : ""}`
          : "Screenshot saved in session.";
        const filename = `winebot_${Date.now()}.png`;
        if (download) {
          const anchor = document.createElement("a");
          anchor.href = url;
          anchor.download = filename;
          anchor.click();
          logMessage("info", `${message} Downloaded to your computer as ${filename}.`);
        } else {
          logMessage("info", message, { link: url, linkLabel: "Download", downloadName: filename });
        }
      } catch (err) {
        logMessage("error", `Screenshot error: ${err.message}`);
      }
    }

    async function postRecordingAction(action) {
      logMessage("info", `Recording ${action} requested.`);
      
      // Optimistic UI update
      const allBtns = [recordStartBtn, recordPauseBtn, recordResumeBtn, recordStopBtn];
      allBtns.forEach(btn => btn.disabled = true);
      
      try {
        const options = { method: "POST" };
        const response = await apiFetch(`/recording/${action}`, options);
        if (!response.ok) {
          throw new Error(`Recording ${action} failed: ${response.status}`);
        }
        const data = await response.json();
        logMessage("info", `Recording ${action}: ${data.status || "ok"}`);
        // Trigger immediate poll to confirm state
        setTimeout(runPoll, 500);
      } catch (err) {
        logMessage("error", `Recording ${action} error: ${err.message}`);
        // Revert UI on error (next poll will fix it anyway, but fast feedback is good)
        updateDashboard(); 
      }
    }

    async function requestShutdown(powerOff) {
      const confirmText = powerOff
        ? "Power off immediately? This is unsafe and skips graceful shutdown."
        : "Gracefully shut down WineBot?";
      if (!window.confirm(confirmText)) {
        return;
      }
      logMessage("warn", powerOff ? "Powering off..." : "Graceful shutdown requested.");
      try {
        const url = powerOff ? "/lifecycle/shutdown?power_off=true" : "/lifecycle/shutdown";
        const response = await apiFetch(url, { method: "POST" });
        if (!response.ok) {
          throw new Error(`Shutdown failed: ${response.status}`);
        }
        const data = await response.json();
        logMessage("info", `Lifecycle: ${data.status}`);
        if (powerOff) {
          stopPolling("Power off requested", "This tab will close and polling will stop.");
          attemptCloseTab();
        }
      } catch (err) {
        logMessage("error", `Lifecycle error: ${err.message}`);
        if (powerOff) {
          stopPolling("Power off failed", "API error. Polling has stopped.");
        }
      }
    }

    function initTokenControls() {
      tokenInput.value = getToken();
      tokenInput.addEventListener("input", () => {
        setToken(tokenInput.value.trim());
      });
      saveTokenBtn.addEventListener("click", () => {
        setToken(tokenInput.value.trim());
        logMessage("info", "API Token saved.");
        updateDashboard();
      });
      clearTokenBtn.addEventListener("click", () => {
        tokenInput.value = "";
        setToken("");
        updateDashboard();
      });
    }

    function initVncControls() {
      vncHostInput.value = getVncHost();
      vncHostInput.addEventListener("input", () => setVncHost(vncHostInput.value.trim()));
      vncPortInput.value = getVncPort();
      vncPortInput.addEventListener("input", () => setVncPort(vncPortInput.value.trim()));
      vncPasswordInput.value = getVncPassword();
      vncPasswordInput.addEventListener("input", () => {
        setVncPassword(vncPasswordInput.value);
      });
      saveVncBtn.addEventListener("click", () => {
        setVncHost(vncHostInput.value.trim());
        setVncPort(vncPortInput.value.trim());
        setVncPassword(vncPasswordInput.value);
        logMessage("info", "VNC Settings saved.");
        if (vncNeedsCredentials && rfbInstance) {
          const password = getVncPassword();
          if (password) {
            rfbInstance.sendCredentials({ password });
            setBadge(badgeVnc, "sending password…", "warn");
            vncNeedsCredentials = false;
            return;
          }
        }
        restartVnc();
      });
      clearVncBtn.addEventListener("click", () => {
        vncHostInput.value = "";
        vncPortInput.value = "";
        vncPasswordInput.value = "";
        setVncHost("");
        setVncPort("");
        setVncPassword("");
        vncNeedsCredentials = false;
      });

      vncScaleToggle.addEventListener("change", () => {
        if (rfbInstance) {
          rfbInstance.scaleViewport = vncScaleToggle.checked;
        }
      });
      vncViewOnlyToggle.addEventListener("change", () => {
        if (rfbInstance) {
          rfbInstance.viewOnly = vncViewOnlyToggle.checked;
        }
      });
      vncTraceToggle.addEventListener("change", () => {
        setClientTraceEnabled(vncTraceToggle.checked);
      });
      vncReconnectBtn.addEventListener("click", () => {
        restartVnc();
      });
      vncForceFocusBtn.addEventListener("click", () => {
        forceAppFocus();
      });
      document.getElementById("btn-reset-workspace").addEventListener("click", async () => {
        logMessage("info", "Resetting workspace (desktop resolution/decorations)...");
        try {
          const res = await apiFetch("/lifecycle/reset_workspace", { method: "POST" });
          if (res.ok) {
            logMessage("info", "Workspace reset request sent.");
          } else {
            logMessage("error", `Workspace reset failed: ${res.status}`);
          }
        } catch (err) {
          logMessage("error", `Workspace reset error: ${err.message}`);
        }
      });
      vncInjectBtn.addEventListener("click", async () => {
        if (!lastVncClick) return;
        logMessage("info", `Injecting API click at (${lastVncClick.x}, ${lastVncClick.y})...`);
        try {
          const response = await apiFetch("/input/mouse/click", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(lastVncClick)
          });
          if (response.ok) {
            logMessage("info", "API click injected successfully.");
          } else {
            logMessage("error", `API click injection failed: ${response.status}`);
          }
        } catch (err) {
          logMessage("error", `API click injection error: ${err.message}`);
        }
      });
    }

    function initActions() {
      screenshotBtn.addEventListener("click", () => takeScreenshot({ download: false }));
      screenshotDownloadBtn.addEventListener("click", () => takeScreenshot({ download: true }));
      recordStartBtn.addEventListener("click", () => postRecordingAction("start"));
      recordPauseBtn.addEventListener("click", () => postRecordingAction("pause"));
      recordResumeBtn.addEventListener("click", () => postRecordingAction("resume"));
      recordStopBtn.addEventListener("click", () => postRecordingAction("stop"));
      shutdownBtn.addEventListener("click", () => requestShutdown(false));
      powerOffBtn.addEventListener("click", () => requestShutdown(true));
      resumePollingBtn.addEventListener("click", () => {
        const reason = sessionEndedReason;
        pollStopped = false;
        pollMode = "backoff";
        backoffIndex = 0;
        backoffElapsedMs = 0;
        if (reason === "vnc") {
          restartVnc();
        }
        logMessage("info", "Resuming polling...");
        scheduleNextPoll(BASE_BACKOFF_MS);
      });
      closeTabBtn.addEventListener("click", () => {
        attemptCloseTab();
      });
    }

    function initLogControls() {
      if (!logClearBtn || !logEntries || !logConsole || !logToggleBtn) {
        return;
      }
      logClearBtn.addEventListener("click", () => {
        logEntries.innerHTML = "";
        loggedEvents.clear();
        logMessage("info", "Log cleared.");
      });
      const logKey = "winebot_log_collapsed";
      const logSaved = localStorage.getItem(logKey);
      if (logSaved === "collapsed") {
        logConsole.classList.add("collapsed");
        logToggleBtn.setAttribute("aria-expanded", "false");
      }
      logToggleBtn.addEventListener("click", () => {
        const collapsed = logConsole.classList.toggle("collapsed");
        logToggleBtn.setAttribute("aria-expanded", collapsed ? "false" : "true");
        localStorage.setItem(logKey, collapsed ? "collapsed" : "expanded");
      });
      logMessage("info", "Dashboard loaded.");
    }

    function initCollapsibles() {
      const sections = document.querySelectorAll(".panel-section[data-collapsible]");
      const forcedCollapsed = new Set(["configuration", "api console", "vnc settings"]);
      sections.forEach((section) => {
        const toggle = section.querySelector(".section-toggle");
        const title = section.querySelector(".section-title span");
        if (!toggle || !title) {
          return;
        }
        const titleText = title.textContent.trim().toLowerCase();
        const key = `winebot_panel_${titleText.replace(/\s+/g, "_")}`;
        const saved = localStorage.getItem(key);
        const shouldForceCollapse = forcedCollapsed.has(titleText);
        if (shouldForceCollapse || saved === "collapsed") {
          section.classList.add("collapsed");
          toggle.setAttribute("aria-expanded", "false");
        }
        toggle.addEventListener("click", () => {
          const collapsed = section.classList.toggle("collapsed");
          toggle.setAttribute("aria-expanded", collapsed ? "false" : "true");
          if (shouldForceCollapse) {
            localStorage.setItem(key, "collapsed");
          } else {
            localStorage.setItem(key, collapsed ? "collapsed" : "expanded");
          }
        });
      });
    }

    const API_TEMPLATES = {
      health: { method: "GET", path: "/health", body: "" },
      sessions: { method: "GET", path: "/sessions", body: "" },
      suspend: { method: "POST", path: "/sessions/suspend", body: JSON.stringify({ shutdown_wine: true, stop_recording: true }, null, 2) },
      resume: { method: "POST", path: "/sessions/resume", body: JSON.stringify({ restart_wine: true, stop_recording: true }, null, 2) },
      "record-start": { method: "POST", path: "/recording/start", body: JSON.stringify({ new_session: false }, null, 2) },
      "record-stop": { method: "POST", path: "/recording/stop", body: "" },
      lifecycle: { method: "GET", path: "/lifecycle/status", body: "" },
      shutdown: { method: "POST", path: "/lifecycle/shutdown", body: "" },
      windows: { method: "GET", path: "/windows", body: "" },
      apps: { method: "GET", path: "/apps", body: "" },
      inspect: { method: "POST", path: "/inspect/window", body: JSON.stringify({ list_only: true }, null, 2) }
    };

    function initApiConsole() {
      apiPathInput.value = "/health";
      apiSendBtn.addEventListener("click", () => sendApiConsole(false));
      apiSendForceBtn.addEventListener("click", () => sendApiConsole(true));
      apiTemplateButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const template = API_TEMPLATES[button.dataset.apiTemplate];
          if (!template) {
            return;
          }
          apiMethodSelect.value = template.method;
          apiPathInput.value = template.path;
          apiBodyInput.value = template.body || "";
        });
      });
    }

    async function initVnc() {
      badgeVnc.textContent = "connecting...";
      console.log("Initializing VNC connection...");
      try {
        let mod;
        try {
            mod = await import("./core/rfb.js");
        } catch (e) {
            console.error("Failed to import rfb.js:", e);
            setBadge(badgeVnc, "client missing", "error");
            logMessage("error", "Failed to load VNC client (rfb.js).");
            return;
        }
        console.log("rfb.js module loaded successfully.");
        resetVncCanvas();
        
        // Dynamic host and port detection
        let vncHost = getVncHost() || window.location.hostname;
        let vncPort = getVncPort();
        
        if (!vncPort) {
            vncPort = window.location.port || (window.location.protocol === "https:" ? "443" : "80");
            // If we are on port 8000 (API), we assume noVNC is on 6080 (standard mapping)
            if (vncPort === "8000") {
                vncPort = "6080";
            }
        }
        
        const protocol = window.location.protocol === "https:" ? "wss" : "ws";
        const wsUrl = `${protocol}://${vncHost}:${vncPort}/`;
        console.log(`Attempting to connect to VNC at: ${wsUrl}`);
        
        let connectionTimeout = setTimeout(() => {
            if (!vncConnected) {
                console.error("VNC Connection Timed Out");
                setBadge(badgeVnc, "timeout", "error");
                logMessage("error", "VNC connection timed out.");
                if (rfbInstance) {
                    try { rfbInstance.disconnect(); } catch (e) {}
                }
            }
        }, 10000);

        rfbInstance = new mod.default(vncContainer, wsUrl);
        rfbInstance.viewOnly = vncViewOnlyToggle.checked;
        rfbInstance.scaleViewport = vncScaleToggle.checked;
        rfbInstance.resizeSession = false;
        rfbInstance.clipViewport = !vncScaleToggle.checked;
        rfbInstance.addEventListener("connect", () => {
          clearTimeout(connectionTimeout);
          setBadge(badgeVnc, "connected", "ok");
          vncConnected = true;
          if (typeof rfbInstance.focus === "function") {
            rfbInstance.focus();
          }
          const canvas = vncContainer.querySelector("canvas");
          if (canvas) {
            vncTraceCanvas = canvas;
            attachVncKeyListeners();
            canvas.addEventListener("mousedown", (e) => {
              const rect = canvas.getBoundingClientRect();
              const x = e.clientX - rect.left;
              const y = e.clientY - rect.top;
              const vncX = Math.floor(x * (canvas.width / rect.width));
              const vncY = Math.floor(y * (canvas.height / rect.height));
              lastVncClick = { x: vncX, y: vncY };
              vncInjectBtn.disabled = false;
              updateInputDebug(`Mousedown: client(${Math.round(x)},${Math.round(y)}) -> VNC(${vncX},${vncY})`);
              logMessage("info", `Mouse down at client(${Math.round(x)}, ${Math.round(y)}) -> VNC(${vncX}, ${vncY})`);
            });
            canvas.addEventListener("mousedown", (e) => {
              if (!canTraceClientEvent()) return;
              const coords = getCanvasCoords(canvas, e);
              postClientTraceEvent({
                event: "client_mouse_down",
                button: e.button,
                buttons: e.buttons,
                ctrl: e.ctrlKey,
                alt: e.altKey,
                shift: e.shiftKey,
                meta: e.metaKey,
                ...coords
              });
            });
            canvas.addEventListener("mouseup", (e) => {
              if (!canTraceClientEvent()) return;
              const coords = getCanvasCoords(canvas, e);
              postClientTraceEvent({
                event: "client_mouse_up",
                button: e.button,
                buttons: e.buttons,
                ctrl: e.ctrlKey,
                alt: e.altKey,
                shift: e.shiftKey,
                meta: e.metaKey,
                ...coords
              });
            });
            canvas.addEventListener("mousemove", (e) => {
              if (!canTraceClientEvent()) return;
              const now = performance.now();
              if (now - vncTraceLastMoveTs < 25) {
                return;
              }
              vncTraceLastMoveTs = now;
              const coords = getCanvasCoords(canvas, e);
              postClientTraceEvent({
                event: "client_mouse_move",
                buttons: e.buttons,
                ...coords
              });
            });
            canvas.addEventListener("wheel", (e) => {
              if (!canTraceClientEvent()) return;
              const coords = getCanvasCoords(canvas, e);
              postClientTraceEvent({
                event: "client_mouse_wheel",
                delta_x: e.deltaX,
                delta_y: e.deltaY,
                delta_z: e.deltaZ,
                delta_mode: e.deltaMode,
                ...coords
              });
            }, { passive: true });
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = rect.width ? (canvas.width / rect.width) : 0;
            const scaleY = rect.height ? (canvas.height / rect.height) : 0;
            logMessage("info", `VNC canvas ${canvas.width}x${canvas.height}, client ${Math.round(rect.width)}x${Math.round(rect.height)} (scale ${scaleX.toFixed(2)}x${scaleY.toFixed(2)})`);
            if (scaleX && scaleY && (Math.abs(scaleX - 1) > 0.02 || Math.abs(scaleY - 1) > 0.02)) {
              logMessage("warn", "VNC canvas is scaled in the browser. Mouse clicks can be offset; consider 100% zoom or 1:1 mode.");
            }
          }
          logMessage("info", "Live session connected.");
          if (sessionEndedReason === "vnc") {
            exitBackoff("vnc");
          }
        });
        rfbInstance.addEventListener("disconnect", () => {
          clearTimeout(connectionTimeout);
          setBadge(badgeVnc, "disconnected", "error");
          vncConnected = false;
          logMessage("warn", "Live session disconnected.");
          enterBackoff("vnc", "Live session disconnected", "noVNC connection lost. Waiting for the live session to reconnect.");
        });
        rfbInstance.addEventListener("credentialsrequired", () => {
          clearTimeout(connectionTimeout);
          const password = getVncPassword();
          vncNeedsCredentials = true;
          if (password) {
            rfbInstance.sendCredentials({ password });
            setBadge(badgeVnc, "sending password…", "warn");
            vncNeedsCredentials = false;
            logMessage("info", "VNC password sent.");
          } else {
            setBadge(badgeVnc, "password required", "warn");
            logMessage("warn", "VNC password required.");
          }
        });
      } catch (err) {
        console.error("VNC Initialization Error:", err);
        logMessage("error", `VNC Load Error: ${err.message}`);
        setBadge(badgeVnc, "noVNC load failed", "error");
      }
    }

    function restartVnc() {
      try {
        if (rfbInstance) {
          rfbInstance.disconnect();
        }
      } catch (err) {
        // Ignore disconnect errors.
      }
      initVnc();
    }

    let versionLoaded = false;
    async function updateVersion() {
      if (versionLoaded) return;
      const badgeVersion = document.getElementById("badge-version");
      try {
        const res = await apiFetch("/version");
        if (res && res.ok) {
          const data = await res.json();
          if (data && data.version) {
            badgeVersion.textContent = `Release ${data.version}`;
            versionLoaded = true;
          }
        }
      } catch (err) {
        console.error("Failed to fetch version:", err);
      }
    }

    initTokenControls();
    initVncControls();
    initActions();
    initApiConsole();
    initLogControls();
    initCollapsibles();
    initVnc();

    updateVersion();
    runPoll();
  </script>
</body>
</html>
