<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <base href="/ui/" />
  <title>WineBot Dashboard</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b1114;
      --panel: #121a1f;
      --panel-2: #18232b;
      --accent: #4dd0a1;
      --accent-2: #5ec4ff;
      --text: #e6f0f4;
      --muted: #9fb3bf;
      --danger: #ff6b6b;
      --warn: #f7c96f;
      --ok: #4dd0a1;
      --border: #22303a;
      --shadow: rgba(0, 0, 0, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Space Grotesk", "Sora", "IBM Plex Sans", "Segoe UI", sans-serif;
      background: radial-gradient(1200px 700px at 10% 10%, #142028 0%, #0b1114 65%);
      color: var(--text);
    }

    #dashboard {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    #app {
      display: flex;
      flex: 1;
      min-height: 0;
    }

    #vnc-container {
      flex: 0 0 75%;
      min-width: 0;
      position: relative;
      display: block;
      background: linear-gradient(135deg, #0b1114 0%, #0f1a20 60%, #0c1419 100%);
      border-right: 1px solid var(--border);
      overflow: hidden;
      pointer-events: auto;
    }

    #vnc-container canvas {
      outline: none;
      width: 100% !important;
      height: 100% !important;
      display: block;
      pointer-events: auto;
    }

    .vnc-overlay {
      position: absolute;
      top: 16px;
      left: 16px;
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 10px 14px;
      background: rgba(18, 26, 31, 0.78);
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: 0 8px 24px var(--shadow);
      backdrop-filter: blur(8px);
      z-index: 5;
      pointer-events: none;
    }

    .vnc-overlay-right {
      left: auto;
      right: 16px;
      text-align: right;
    }

    .vnc-overlay-right .badge {
      white-space: nowrap;
    }

    .vnc-title {
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    #control-panel {
      flex: 0 0 25%;
      min-width: 280px;
      padding: 24px 20px;
      background: var(--panel);
      display: flex;
      flex-direction: column;
      gap: 18px;
      overflow-y: auto;
    }

    .panel-header h1 {
      font-size: 1.4rem;
      margin: 0 0 6px;
    }

    .panel-header p {
      margin: 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .panel-section {
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 8px 18px var(--shadow);
    }

    .config-block {
      padding: 10px 0;
      border-bottom: 1px solid rgba(34, 48, 58, 0.6);
    }

    .config-block:last-of-type {
      border-bottom: 0;
      padding-bottom: 0;
    }

    .config-title {
      font-size: 0.85rem;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text);
    }

    .section-title {
      font-size: 0.95rem;
      font-weight: 600;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .section-toggle {
      border: 1px solid var(--border);
      background: transparent;
      color: var(--muted);
      font-size: 0.75rem;
      padding: 4px 8px;
      border-radius: 999px;
      cursor: pointer;
    }

    .section-toggle:hover {
      color: var(--text);
      border-color: rgba(94, 196, 255, 0.35);
    }

    .panel-section.collapsed .panel-body {
      display: none;
    }

    .panel-section.collapsed .section-toggle {
      transform: rotate(-90deg);
    }

    label {
      display: block;
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 6px;
    }

    input[type="password"],
    input[type="text"] {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #0d1418;
      color: var(--text);
      font-size: 0.9rem;
    }

    textarea {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #0d1418;
      color: var(--text);
      font-size: 0.82rem;
      font-family: "IBM Plex Mono", "JetBrains Mono", "SFMono-Regular", monospace;
      min-height: 120px;
      resize: vertical;
    }

    select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #0d1418;
      color: var(--text);
      font-size: 0.9rem;
    }

    button {
      border: 0;
      border-radius: 8px;
      padding: 8px 12px;
      font-weight: 600;
      background: var(--accent);
      color: #08110e;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease, opacity 120ms ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(77, 208, 161, 0.25);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    button.secondary {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--border);
    }

    button.warn {
      background: var(--warn);
      color: #1c1200;
    }

    button.danger {
      background: var(--danger);
      color: #1f0707;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .api-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
    }

    .api-row select {
      flex: 0 0 90px;
    }

    .api-row input {
      flex: 1;
    }

    .api-templates {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }

    .chip {
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 4px 10px;
      background: #0f171d;
      color: var(--muted);
      font-size: 0.72rem;
      cursor: pointer;
    }

    .code-block {
      margin-top: 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0d1418;
      padding: 10px;
      font-family: "IBM Plex Mono", "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 0.76rem;
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 220px;
      overflow: auto;
      color: var(--muted);
    }

    .code-block.ok {
      border-color: rgba(77, 208, 161, 0.35);
      color: var(--text);
    }

    .code-block.error {
      border-color: rgba(255, 107, 107, 0.4);
      color: var(--danger);
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .toggle input {
      accent-color: var(--accent);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #0f171d;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .badge.compact {
      padding: 4px 8px;
      font-size: 0.72rem;
      gap: 4px;
    }

    .badge.compact::before {
      content: "●";
      font-size: 0.55rem;
      line-height: 1;
      color: currentColor;
    }

    .badge-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      align-items: start;
    }

    .badge.ok {
      border-color: rgba(77, 208, 161, 0.4);
      color: var(--ok);
    }

    .badge.warn {
      border-color: rgba(247, 201, 111, 0.4);
      color: var(--warn);
    }

    .badge.error {
      border-color: rgba(255, 107, 107, 0.4);
      color: var(--danger);
    }

    .hint {
      margin-top: 6px;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .status-text {
      margin-top: 8px;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .events-list {
      margin-top: 10px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0f171d;
      max-height: 160px;
      overflow-y: auto;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .events-list div {
      margin-bottom: 6px;
    }

    .events-list div:last-child {
      margin-bottom: 0;
    }

    .hidden {
      display: none !important;
    }

    .session-ended {
      position: fixed;
      inset: 0;
      background: rgba(7, 10, 12, 0.92);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      padding: 24px;
    }

    .ended-card {
      width: min(520px, 90vw);
      background: #0f171d;
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: 0 24px 48px rgba(0, 0, 0, 0.45);
      padding: 22px;
      text-align: left;
    }

    .ended-card h2 {
      margin: 0 0 8px;
      font-size: 1.3rem;
    }

    .ended-card p {
      margin: 6px 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .ended-actions {
      margin-top: 14px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    #log-console {
      border-top: 1px solid var(--border);
      background: #0b1114;
      padding: 12px 18px 16px;
      min-height: 120px;
      max-height: 220px;
    }

    #log-console.collapsed {
      min-height: 0;
      max-height: 48px;
      padding-bottom: 10px;
    }

    #log-console.collapsed .log-entries {
      display: none;
    }

    #log-console.collapsed #log-toggle {
      transform: rotate(-90deg);
    }

    .log-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .log-actions {
      display: flex;
      gap: 8px;
    }

    .log-entries {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #0d1418;
      padding: 10px;
      height: clamp(110px, 18vh, 170px);
      overflow-y: auto;
      font-family: "IBM Plex Mono", "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .log-entry {
      display: grid;
      grid-template-columns: 90px 1fr;
      gap: 10px;
      margin-bottom: 6px;
    }

    .log-entry:last-child {
      margin-bottom: 0;
    }

    .log-entry .log-time {
      color: var(--muted);
      white-space: nowrap;
    }

    .log-entry.info .log-message {
      color: var(--text);
    }

    .log-entry.warn .log-message {
      color: var(--warn);
    }

    .log-entry.error .log-message {
      color: var(--danger);
    }

    .log-entry .log-message a {
      color: var(--accent-2);
      text-decoration: none;
    }

    @media (max-width: 980px) {
      #app {
        flex-direction: column;
      }

      #vnc-container,
      #control-panel {
        flex: 0 0 auto;
        width: 100%;
      }

      #vnc-container {
        min-height: 55vh;
      }

      #control-panel {
        max-height: 40vh;
      }

      .badge-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div id="dashboard">
    <div id="app">
      <section id="vnc-container">
        <div class="vnc-overlay">
          <div class="vnc-title">Live Session</div>
          <div id="badge-vnc" class="badge">connecting...</div>
        </div>
        <div class="vnc-overlay vnc-overlay-right">
          <div class="vnc-title">WineBot</div>
          <div class="badge" id="badge-version">Release v0.8.0-18-g48f5d13-dirty · Commit 48f5d13</div>
        </div>
      </section>

      <aside id="control-panel">
      <div class="panel-header">
        <h1>WineBot Dashboard</h1>
        <p>Control the session and check system health.</p>
      </div>

      <div class="panel-section" data-collapsible>
        <div class="section-title">
          <span>Configuration</span>
          <button class="section-toggle" type="button" aria-expanded="true">▾</button>
        </div>
        <div class="panel-body">
          <div class="config-block">
            <div class="config-title">API Access</div>
            <label for="api-token">API Token (optional)</label>
            <input id="api-token" type="password" placeholder="X-API-Key" />
            <div class="button-row" style="margin-top: 10px;">
              <button id="save-token" class="secondary">Save Token</button>
              <button id="clear-token" class="secondary">Clear</button>
            </div>
            <div class="hint">Stored in localStorage for this browser.</div>
          </div>
          <div class="config-block">
            <div class="config-title">VNC Access</div>
            <label for="vnc-password">VNC Password</label>
            <input id="vnc-password" type="password" placeholder="VNC password" />
            <div class="button-row" style="margin-top: 10px;">
              <button id="save-vnc" class="secondary">Save Password</button>
              <button id="clear-vnc" class="secondary">Clear</button>
            </div>
            <div class="hint">Used only for the embedded noVNC session.</div>
          </div>
        </div>
      </div>

      <div class="panel-section" data-collapsible>
        <div class="section-title">
          <span>Lifecycle</span>
          <button class="section-toggle" type="button" aria-expanded="true">▾</button>
        </div>
        <div class="panel-body">
          <div class="button-row">
            <button id="btn-shutdown" class="warn">Graceful Shutdown</button>
            <button id="btn-poweroff" class="danger">Power Off</button>
          </div>
          <div class="badge-grid">
            <span id="badge-xvfb" class="badge compact">Xvfb: pending</span>
            <span id="badge-openbox" class="badge compact">Openbox: pending</span>
            <span id="badge-vnc-process" class="badge compact">VNC: pending</span>
            <span id="badge-novnc" class="badge compact">noVNC: pending</span>
            <span id="badge-wine" class="badge compact">Wine: pending</span>
          </div>
        </div>
      </div>

      <div class="panel-section" data-collapsible>
        <div class="section-title">
          <span>Quick Actions</span>
          <button class="section-toggle" type="button" aria-expanded="true">▾</button>
        </div>
        <div class="panel-body">
          <div class="button-row">
            <button id="btn-screenshot">Capture Screenshot</button>
            <button id="btn-screenshot-download" class="secondary">Download Screenshot</button>
          </div>
          <div id="recording-panel" style="margin-top: 14px;">
            <div class="section-title">Recording</div>
          <div class="button-row">
            <button id="btn-record-start">Start</button>
            <button id="btn-record-pause" class="warn">Pause</button>
            <button id="btn-record-resume" class="secondary">Resume</button>
            <button id="btn-record-stop" class="danger">Stop</button>
          </div>
          </div>
        </div>
      </div>

      <div class="panel-section" data-collapsible>
        <div class="section-title">
          <span>Health</span>
          <button class="section-toggle" type="button" aria-expanded="true">▾</button>
        </div>
        <div class="panel-body">
          <div class="badge-grid">
            <span id="badge-health" class="badge compact">/health: pending</span>
            <span id="badge-x11" class="badge compact">/health/x11: pending</span>
            <span id="badge-windows" class="badge compact">/health/windows: pending</span>
            <span id="badge-recording" class="badge compact">/health/recording: pending</span>
            <span id="badge-storage" class="badge compact">/health/storage: pending</span>
          </div>
        </div>
      </div>

      <div class="panel-section" data-collapsible>
        <div class="section-title">
          <span>API Console</span>
          <button class="section-toggle" type="button" aria-expanded="true">▾</button>
        </div>
        <div class="panel-body">
          <div class="api-row">
            <select id="api-method">
              <option value="GET">GET</option>
              <option value="POST">POST</option>
              <option value="PUT">PUT</option>
              <option value="DELETE">DELETE</option>
            </select>
            <input id="api-path" type="text" placeholder="/health" />
          </div>
          <label for="api-body">JSON Body (optional)</label>
          <textarea id="api-body" rows="6" placeholder='{"key":"value"}'></textarea>
          <div class="button-row" style="justify-content: space-between; align-items: center;">
            <div class="button-row">
              <button id="api-send">Send</button>
              <button id="api-send-force" class="secondary">Force Send</button>
            </div>
            <label class="toggle">
              <input type="checkbox" id="api-idempotent" checked />
              <span>Idempotent</span>
            </label>
          </div>
          <div class="api-templates">
            <button class="chip" data-api-template="health">/health</button>
            <button class="chip" data-api-template="sessions">/sessions</button>
            <button class="chip" data-api-template="suspend">Suspend session</button>
            <button class="chip" data-api-template="resume">Resume session</button>
            <button class="chip" data-api-template="record-start">Record start</button>
            <button class="chip" data-api-template="record-stop">Record stop</button>
            <button class="chip" data-api-template="lifecycle">/lifecycle/status</button>
            <button class="chip" data-api-template="shutdown">Shutdown</button>
            <button class="chip" data-api-template="windows">/windows</button>
            <button class="chip" data-api-template="apps">/apps</button>
            <button class="chip" data-api-template="inspect">Inspect window</button>
          </div>
          <div id="api-response" class="code-block">Response: waiting…</div>
        </div>
      </div>
      </aside>
    </div>

    <div id="log-console">
      <div class="log-header">
        <div>Activity Log</div>
        <div class="log-actions">
          <button id="log-toggle" class="section-toggle" type="button" aria-expanded="true">▾</button>
          <button id="log-clear" class="secondary">Clear</button>
        </div>
      </div>
      <div id="log-entries" class="log-entries"></div>
    </div>
  </div>

  <div id="session-ended" class="session-ended hidden">
    <div class="ended-card">
      <h2>WineBot disconnected</h2>
      <p id="ended-reason">The WineBot API or live session is unreachable.</p>
      <p id="ended-detail">This dashboard will keep polling to reconnect to the current WineBot session.</p>
      <div class="ended-actions">
        <button id="btn-resume" class="secondary">Continue polling</button>
        <button id="btn-close-tab" class="danger">Close tab</button>
      </div>
    </div>
  </div>

  <script type="module">
    const vncContainer = document.getElementById("vnc-container");
    const badgeVnc = document.getElementById("badge-vnc");
    const badgeXvfb = document.getElementById("badge-xvfb");
    const badgeOpenbox = document.getElementById("badge-openbox");
    const badgeVncProcess = document.getElementById("badge-vnc-process");
    const badgeNoVnc = document.getElementById("badge-novnc");
    const badgeWine = document.getElementById("badge-wine");
    const badgeHealth = document.getElementById("badge-health");
    const badgeX11 = document.getElementById("badge-x11");
    const badgeWindows = document.getElementById("badge-windows");
    const badgeRecording = document.getElementById("badge-recording");
    const badgeStorage = document.getElementById("badge-storage");

    const tokenInput = document.getElementById("api-token");
    const saveTokenBtn = document.getElementById("save-token");
    const clearTokenBtn = document.getElementById("clear-token");
    const vncPasswordInput = document.getElementById("vnc-password");
    const saveVncBtn = document.getElementById("save-vnc");
    const clearVncBtn = document.getElementById("clear-vnc");

    const screenshotBtn = document.getElementById("btn-screenshot");
    const screenshotDownloadBtn = document.getElementById("btn-screenshot-download");

    const recordStartBtn = document.getElementById("btn-record-start");
    const recordPauseBtn = document.getElementById("btn-record-pause");
    const recordResumeBtn = document.getElementById("btn-record-resume");
    const recordStopBtn = document.getElementById("btn-record-stop");
    const recordingPanel = document.getElementById("recording-panel");
    const apiMethodSelect = document.getElementById("api-method");
    const apiPathInput = document.getElementById("api-path");
    const apiBodyInput = document.getElementById("api-body");
    const apiSendBtn = document.getElementById("api-send");
    const apiSendForceBtn = document.getElementById("api-send-force");
    const apiIdempotentToggle = document.getElementById("api-idempotent");
    const apiResponse = document.getElementById("api-response");
    const apiTemplateButtons = document.querySelectorAll("[data-api-template]");
    const shutdownBtn = document.getElementById("btn-shutdown");
    const powerOffBtn = document.getElementById("btn-poweroff");
    const sessionEndedOverlay = document.getElementById("session-ended");
    const endedReason = document.getElementById("ended-reason");
    const endedDetail = document.getElementById("ended-detail");
    const resumePollingBtn = document.getElementById("btn-resume");
    const closeTabBtn = document.getElementById("btn-close-tab");
    const logConsole = document.getElementById("log-console");
    const logToggleBtn = document.getElementById("log-toggle");
    const logEntries = document.getElementById("log-entries");
    const logClearBtn = document.getElementById("log-clear");

    const API_TOKEN_KEY = "winebot_api_token";
    const VNC_PASSWORD_KEY = "winebot_vnc_password";
    let rfbInstance = null;
    let vncNeedsCredentials = false;
    let vncConnected = false;
    let pollTimer = null;
    let pollStopped = false;
    let pollMode = "normal";
    let pollFailureStreak = 0;
    let backoffIndex = 0;
    let backoffElapsedMs = 0;
    const BASE_BACKOFF_MS = 5000;
    const MAX_BACKOFF_MS = 180000;
    const MAX_BACKOFF_DELAY_MS = 60000;
    let sessionEndedReason = null;
    let nextPollAt = 0;
    let countdownTimer = null;
    let lastBackoffReason = null;
    const loggedEvents = new Set();
    const statusSnapshot = {
      sessionId: null,
      recordingState: null,
      recordingEnabled: null
    };

    function getToken() {
      return localStorage.getItem(API_TOKEN_KEY) || "";
    }

    function setToken(value) {
      if (value) {
        localStorage.setItem(API_TOKEN_KEY, value);
      } else {
        localStorage.removeItem(API_TOKEN_KEY);
      }
    }

    function getVncPassword() {
      return localStorage.getItem(VNC_PASSWORD_KEY) || "";
    }

    function setVncPassword(value) {
      if (value) {
        localStorage.setItem(VNC_PASSWORD_KEY, value);
      } else {
        localStorage.removeItem(VNC_PASSWORD_KEY);
      }
    }


    function resetVncCanvas() {
      const canvases = vncContainer.querySelectorAll("canvas");
      canvases.forEach((canvas) => canvas.remove());
    }

    function setBadge(element, text, state) {
      element.textContent = text;
      element.classList.remove("ok", "warn", "error");
      if (state) {
        element.classList.add(state);
      }
    }

    function setProcessBadge(element, label, running) {
      const status = running ? "running" : "down";
      setBadge(element, `${label}: ${status}`, running ? "ok" : "error");
    }

    function logMessage(level, message, options = {}) {
      if (!logEntries) {
        return;
      }
      const entry = document.createElement("div");
      entry.classList.add("log-entry", level || "info");
      const time = document.createElement("div");
      time.classList.add("log-time");
      time.textContent = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
      const msg = document.createElement("div");
      msg.classList.add("log-message");
      msg.textContent = message;
      if (options.link && options.linkLabel) {
        const space = document.createTextNode(" ");
        const anchor = document.createElement("a");
        anchor.href = options.link;
        anchor.textContent = options.linkLabel;
        anchor.target = "_blank";
        if (options.downloadName) {
          anchor.download = options.downloadName;
        }
        msg.appendChild(space);
        msg.appendChild(anchor);
      }
      entry.appendChild(time);
      entry.appendChild(msg);
      logEntries.appendChild(entry);
      logEntries.scrollTop = logEntries.scrollHeight;
    }

    function logLifecycleEvents(events) {
      if (!Array.isArray(events)) {
        return;
      }
      events.forEach((event) => {
        const key = `${event.timestamp_utc}|${event.kind}|${event.message}`;
        if (loggedEvents.has(key)) {
          return;
        }
        loggedEvents.add(key);
        const kind = event.kind || "event";
        const message = event.message || "";
        const level = /fail|error|failed/i.test(kind) ? "error" : /warn|stop_failed/i.test(kind) ? "warn" : "info";
        logMessage(level, `${kind} ${message}`.trim());
      });
    }

    function showSessionEnded(reasonKey, reasonText, detailText) {
      sessionEndedReason = reasonKey;
      if (reasonKey === "vnc") {
        endedReason.textContent = "Live session disconnected.";
        endedDetail.textContent = "WineBot is running; waiting for the live session to reconnect.";
      } else if (reasonKey === "api") {
        endedReason.textContent = "WineBot API disconnected.";
        endedDetail.textContent = "Polling for the WineBot session to return (same container or after restart).";
      } else if (reasonKey === "poweroff") {
        endedReason.textContent = "WineBot powered off.";
        endedDetail.textContent = "Polling is stopped. Start WineBot again to reconnect.";
      } else {
        endedReason.textContent = reasonText || "WineBot disconnected.";
        endedDetail.textContent = detailText || "See the activity log for details.";
      }
      sessionEndedOverlay.classList.remove("hidden");
    }

    function hideSessionEnded() {
      sessionEndedReason = null;
      sessionEndedOverlay.classList.add("hidden");
    }

    function setResumeState(enabled, label) {
      resumePollingBtn.disabled = !enabled;
      resumePollingBtn.textContent = label || (enabled ? "Continue polling" : "Polling stopped");
    }

    function enterBackoff(reasonKey, reasonText, detailText) {
      const switchingReason = sessionEndedReason && sessionEndedReason !== reasonKey;
      if (pollMode !== "backoff" || switchingReason) {
        backoffIndex = 0;
        backoffElapsedMs = 0;
      }
      pollMode = "backoff";
      if (!sessionEndedReason || sessionEndedReason !== reasonKey) {
        showSessionEnded(reasonKey, reasonText, detailText);
      }
      if (reasonKey !== "poweroff") {
        setResumeState(true, "Continue polling");
      }
      if (lastBackoffReason !== reasonKey || switchingReason) {
        logMessage("warn", `${reasonText} ${detailText}`.trim());
        lastBackoffReason = reasonKey;
      }
    }

    function exitBackoff(reasonKey) {
      if (sessionEndedReason === reasonKey) {
        hideSessionEnded();
      }
      logMessage("info", reasonKey === "vnc" ? "Live session reconnected." : "API connection restored.");
      pollMode = "normal";
      pollFailureStreak = 0;
      backoffIndex = 0;
      backoffElapsedMs = 0;
      pollStopped = false;
      stopCountdown();
    }

    function nextPollDelay() {
      if (pollMode === "backoff") {
        const delay = Math.min(MAX_BACKOFF_DELAY_MS, BASE_BACKOFF_MS * (2 ** backoffIndex));
        if (backoffElapsedMs + delay >= MAX_BACKOFF_MS) {
          pollStopped = true;
          logMessage("warn", "Polling stopped after repeated reconnect attempts.");
          return null;
        }
        backoffIndex += 1;
        backoffElapsedMs += delay;
        return delay;
      }
      return 5000;
    }

    function stopCountdown() {
      if (countdownTimer) {
        clearInterval(countdownTimer);
        countdownTimer = null;
      }
    }

    function stopPolling(reasonText, detailText) {
      pollStopped = true;
      if (pollTimer) {
        clearTimeout(pollTimer);
        pollTimer = null;
      }
      stopCountdown();
      showSessionEnded("poweroff", reasonText, detailText);
      logMessage("error", `${reasonText} ${detailText}`.trim());
      setResumeState(false, "Polling stopped");
    }

    function attemptCloseTab() {
      window.close();
      setTimeout(() => {
        if (!window.closed) {
          logMessage("warn", "Tab could not be closed automatically. Please close it manually.");
        }
      }, 300);
    }

    function startCountdown() {
      stopCountdown();
    }

    function scheduleNextPoll(delay) {
      if (pollTimer) {
        clearTimeout(pollTimer);
      }
      if (delay === null) {
        stopCountdown();
        return;
      }
      nextPollAt = Date.now() + delay;
      if (pollMode === "backoff") {
        startCountdown();
      } else {
        stopCountdown();
      }
      pollTimer = setTimeout(runPoll, delay);
    }

    async function runPoll() {
      await updateDashboard();
      if (pollStopped) {
        return;
      }
      scheduleNextPoll(nextPollDelay());
    }

    async function apiFetch(path, options = {}) {
      const headers = new Headers(options.headers || {});
      const token = getToken();
      if (token) {
        headers.set("X-API-Key", token);
      }
      return fetch(path, { ...options, headers });
    }

    async function updateDashboard() {
      try {
        const results = await Promise.allSettled([
          apiFetch("/health"),
          apiFetch("/health/x11"),
          apiFetch("/health/windows"),
          apiFetch("/health/recording"),
          apiFetch("/health/storage"),
          apiFetch("/lifecycle/status"),
          apiFetch("/lifecycle/events?limit=6")
        ]);

        const [healthRes, x11Res, windowsRes, recordingRes, storageRes, lifecycleRes, eventsRes] =
          results.map((result) => (result.status === "fulfilled" ? result.value : null));

        const healthData = healthRes ? await safeJson(healthRes) : null;
        const x11Data = x11Res ? await safeJson(x11Res) : null;
        const windowsData = windowsRes ? await safeJson(windowsRes) : null;
        const recordingData = recordingRes ? await safeJson(recordingRes) : null;
        const storageData = storageRes ? await safeJson(storageRes) : null;
        const lifecycleData = lifecycleRes ? await safeJson(lifecycleRes) : null;
        const eventsData = eventsRes ? await safeJson(eventsRes) : null;

        const apiForbidden = Boolean(healthRes && healthRes.status === 403);
        const apiHealthy = Boolean(healthRes && healthRes.ok && healthData);
        if (apiHealthy) {
          setBadge(badgeHealth, `/health: ${healthData.status}`, healthData.status === "ok" ? "ok" : "warn");
        } else if (healthRes) {
          const label = healthRes.status === 403 ? "auth required" : healthRes.status;
          setBadge(badgeHealth, `/health: ${label}`, healthRes.status === 403 ? "warn" : "error");
        } else {
          setBadge(badgeHealth, `/health: error`, "error");
        }

        if (!apiHealthy && !apiForbidden) {
          pollFailureStreak += 1;
          if (pollFailureStreak >= 2) {
            enterBackoff("api", "WineBot API disconnected", "API is unreachable. Polling for the WineBot session to return.");
          }
        } else if (apiHealthy && pollFailureStreak > 0) {
          pollFailureStreak = 0;
          if (sessionEndedReason === "api") {
            if (!vncConnected) {
              enterBackoff("vnc", "Live session reconnecting", "WineBot API is back. Waiting for the live session to reconnect.");
              restartVnc();
            } else {
              exitBackoff("api");
            }
          } else {
            exitBackoff("api");
          }
        }

        if (x11Res && x11Res.ok && x11Data) {
          const data = x11Data;
          setBadge(badgeX11, `/health/x11: ${data.connected ? "connected" : "down"}`, data.connected ? "ok" : "error");
        } else if (x11Res) {
          const label = x11Res.status === 403 ? "auth required" : x11Res.status;
          setBadge(badgeX11, `/health/x11: ${label}`, x11Res.status === 403 ? "warn" : "error");
        } else {
          setBadge(badgeX11, `/health/x11: error`, "error");
        }

        if (windowsRes && windowsRes.ok && windowsData) {
          const data = windowsData;
          setBadge(badgeWindows, `/health/windows: ${data.count} windows`, data.count > 0 ? "ok" : "warn");
        } else if (windowsRes) {
          const label = windowsRes.status === 403 ? "auth required" : windowsRes.status;
          setBadge(badgeWindows, `/health/windows: ${label}`, windowsRes.status === 403 ? "warn" : "error");
        } else {
          setBadge(badgeWindows, `/health/windows: error`, "error");
        }

        if (recordingRes && recordingRes.ok && recordingData) {
          const data = recordingData;
          const running = data.recorder_running === true;
          const state = data.state || (running ? "recording" : "idle");
          setBadge(badgeRecording, `/health/recording: ${state}`, running ? "ok" : "warn");
          const enabled = data.enabled !== false;
          recordingPanel.style.display = enabled ? "" : "none";
          if (statusSnapshot.recordingEnabled !== enabled) {
            logMessage("info", `Recording ${enabled ? "enabled" : "disabled"}.`);
          }
          statusSnapshot.recordingEnabled = enabled;
          if (statusSnapshot.recordingState !== state) {
            logMessage("info", `Recording state: ${state}.`);
          }
          statusSnapshot.recordingState = state;
          if (!enabled) {
            recordStartBtn.disabled = true;
            recordPauseBtn.disabled = true;
            recordResumeBtn.disabled = true;
            recordStopBtn.disabled = true;
            // Recording disabled; keep updating the rest of the dashboard.
          }
          recordStartBtn.disabled = running;
          recordStopBtn.disabled = !running;
          if (state === "paused") {
            recordPauseBtn.disabled = true;
            recordResumeBtn.disabled = false;
          } else {
            recordPauseBtn.disabled = !running;
            recordResumeBtn.disabled = true;
          }
        } else if (recordingRes) {
          const label = recordingRes.status === 403 ? "auth required" : recordingRes.status;
          setBadge(badgeRecording, `/health/recording: ${label}`, recordingRes.status === 403 ? "warn" : "error");
          recordStartBtn.disabled = false;
          recordPauseBtn.disabled = true;
          recordResumeBtn.disabled = true;
          recordStopBtn.disabled = true;
        } else {
          setBadge(badgeRecording, `/health/recording: error`, "error");
        }

        if (storageRes && storageRes.ok && storageData) {
          const data = storageData;
          setBadge(badgeStorage, `/health/storage: ${data.ok ? "ok" : "check"}`, data.ok ? "ok" : "warn");
        } else if (storageRes) {
          const label = storageRes.status === 403 ? "auth required" : storageRes.status;
          setBadge(badgeStorage, `/health/storage: ${label}`, storageRes.status === 403 ? "warn" : "error");
        } else {
          setBadge(badgeStorage, `/health/storage: error`, "error");
        }

        if (lifecycleRes && lifecycleRes.ok && lifecycleData) {
          const data = lifecycleData;
          if (data.session_id) {
            const session = data.session_id;
            const userDir = data.user_dir || "unknown user dir";
            if (statusSnapshot.sessionId !== session) {
              logMessage("info", `Session active: ${session} (user: ${userDir}).`);
              statusSnapshot.sessionId = session;
            }
          } else if (statusSnapshot.sessionId) {
            logMessage("warn", "Session id not reported by lifecycle status.");
            statusSnapshot.sessionId = null;
          }
          const processes = data.processes || {};
          setProcessBadge(badgeXvfb, "Xvfb", processes.xvfb?.ok === true);
          setProcessBadge(badgeOpenbox, "Openbox", processes.openbox?.ok === true);
          setProcessBadge(badgeVncProcess, "VNC", processes.x11vnc?.ok === true);
          setProcessBadge(badgeNoVnc, "noVNC", processes.novnc?.ok === true);
          setProcessBadge(badgeWine, "Wine", processes.wine_explorer?.ok === true);
          shutdownBtn.disabled = false;
          powerOffBtn.disabled = false;
        } else if (lifecycleRes) {
          const label = lifecycleRes.status === 403 ? "auth required" : lifecycleRes.status;
          setBadge(badgeXvfb, "Xvfb: unknown", "warn");
          setBadge(badgeOpenbox, "Openbox: unknown", "warn");
          setBadge(badgeVncProcess, "VNC: unknown", "warn");
          setBadge(badgeNoVnc, "noVNC: unknown", "warn");
          setBadge(badgeWine, "Wine: unknown", "warn");
          shutdownBtn.disabled = lifecycleRes.status === 403;
          powerOffBtn.disabled = lifecycleRes.status === 403;
        } else {
          setBadge(badgeXvfb, "Xvfb: error", "error");
          setBadge(badgeOpenbox, "Openbox: error", "error");
          setBadge(badgeVncProcess, "VNC: error", "error");
          setBadge(badgeNoVnc, "noVNC: error", "error");
          setBadge(badgeWine, "Wine: error", "error");
          shutdownBtn.disabled = true;
          powerOffBtn.disabled = true;
        }

        if (eventsRes && eventsRes.ok && eventsData) {
          logLifecycleEvents(eventsData.events || []);
        }
      } catch (err) {
        setBadge(badgeHealth, "/health: error", "error");
        pollFailureStreak += 1;
        if (pollFailureStreak >= 2) {
          enterBackoff("api", "WineBot API disconnected", "API is unreachable. Polling for the WineBot session to return.");
        }
      }
    }

    async function safeJson(response) {
      try {
        return await response.json();
      } catch (err) {
        return null;
      }
    }

    const API_CONSOLE_CACHE_KEY = "winebot_api_console_cache";

    function getApiConsoleCache() {
      try {
        const raw = sessionStorage.getItem(API_CONSOLE_CACHE_KEY);
        return raw ? JSON.parse(raw) : {};
      } catch (err) {
        return {};
      }
    }

    function setApiConsoleCache(cache) {
      try {
        sessionStorage.setItem(API_CONSOLE_CACHE_KEY, JSON.stringify(cache));
      } catch (err) {
        // Ignore cache write failures.
      }
    }

    function apiConsoleKey(method, path, body) {
      return `${method}::${path}::${body || ""}`;
    }

    function renderApiResponse(payload, cached) {
      const status = payload.status ?? "unknown";
      const ok = Boolean(payload.ok);
      const origin = cached ? "cached" : "live";
      apiResponse.classList.remove("ok", "error");
      apiResponse.classList.add(ok ? "ok" : "error");
      apiResponse.textContent = `[${status}] ${ok ? "OK" : "ERROR"} (${origin})\n${payload.body || ""}`.trim();
    }

    async function sendApiConsole(force = false) {
      const method = apiMethodSelect.value;
      let path = apiPathInput.value.trim();
      const body = apiBodyInput.value.trim();
      if (!path) {
        apiResponse.textContent = "Response: enter a path to send.";
        apiResponse.classList.remove("ok", "error");
        return;
      }
      if (!path.startsWith("/")) {
        path = `/${path}`;
      }

      const key = apiConsoleKey(method, path, body);
      if (apiIdempotentToggle.checked && !force) {
        const cache = getApiConsoleCache();
        if (cache[key]) {
          renderApiResponse(cache[key], true);
          return;
        }
      }

      apiResponse.classList.remove("ok", "error");
      apiResponse.textContent = "Sending request...";
      try {
        const options = { method };
        if (body && method !== "GET") {
          options.headers = { "Content-Type": "application/json" };
          options.body = body;
        }
        const response = await apiFetch(path, options);
        const contentType = response.headers.get("content-type") || "";
        let payloadText = "";
        if (contentType.includes("application/json")) {
          const data = await safeJson(response);
          payloadText = data ? JSON.stringify(data, null, 2) : "";
        } else if (contentType.startsWith("text/") || contentType === "") {
          payloadText = await response.text();
        } else {
          payloadText = `Binary response (${contentType || "unknown"})`;
        }
        const payload = { status: response.status, ok: response.ok, body: payloadText };
        renderApiResponse(payload, false);
        if (apiIdempotentToggle.checked && response.ok && !force) {
          const cache = getApiConsoleCache();
          cache[key] = payload;
          setApiConsoleCache(cache);
        }
      } catch (err) {
        apiResponse.classList.remove("ok");
        apiResponse.classList.add("error");
        apiResponse.textContent = `API console error: ${err.message}`;
      }
    }

    async function takeScreenshot({ download } = { download: false }) {
      logMessage("info", download ? "Capturing screenshot for download..." : "Capturing screenshot...");
      try {
        const response = await apiFetch("/screenshot");
        if (!response.ok) {
          throw new Error(`Screenshot failed: ${response.status}`);
        }
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        const savedPath = response.headers.get("X-Screenshot-Path");
        const metaPath = response.headers.get("X-Screenshot-Metadata-Path");
        const message = savedPath
          ? `Screenshot saved in session: ${savedPath}${metaPath ? ` (metadata: ${metaPath})` : ""}`
          : "Screenshot saved in session.";
        const filename = `winebot_${Date.now()}.png`;
        if (download) {
          const anchor = document.createElement("a");
          anchor.href = url;
          anchor.download = filename;
          anchor.click();
          logMessage("info", `${message} Downloaded to your computer as ${filename}.`);
        } else {
          logMessage("info", message, { link: url, linkLabel: "Download", downloadName: filename });
        }
      } catch (err) {
        logMessage("error", `Screenshot error: ${err.message}`);
      }
    }

    async function postRecordingAction(action) {
      logMessage("info", `Recording ${action} requested.`);
      try {
        const options = { method: "POST" };
        const response = await apiFetch(`/recording/${action}`, options);
        if (!response.ok) {
          throw new Error(`Recording ${action} failed: ${response.status}`);
        }
        const data = await response.json();
        logMessage("info", `Recording ${action}: ${data.status || "ok"}`);
      } catch (err) {
        logMessage("error", `Recording ${action} error: ${err.message}`);
      }
    }

    async function requestShutdown(powerOff) {
      const confirmText = powerOff
        ? "Power off immediately? This is unsafe and skips graceful shutdown."
        : "Gracefully shut down WineBot?";
      if (!window.confirm(confirmText)) {
        return;
      }
      logMessage("warn", powerOff ? "Powering off..." : "Graceful shutdown requested.");
      try {
        const url = powerOff ? "/lifecycle/shutdown?power_off=true" : "/lifecycle/shutdown";
        const response = await apiFetch(url, { method: "POST" });
        if (!response.ok) {
          throw new Error(`Shutdown failed: ${response.status}`);
        }
        const data = await response.json();
        logMessage("info", `Lifecycle: ${data.status}`);
        if (powerOff) {
          stopPolling("Power off requested", "This tab will close and polling will stop.");
          attemptCloseTab();
        }
      } catch (err) {
        logMessage("error", `Lifecycle error: ${err.message}`);
        if (powerOff) {
          stopPolling("Power off failed", "API error. Polling has stopped.");
        }
      }
    }

    function initTokenControls() {
      tokenInput.value = getToken();
      saveTokenBtn.addEventListener("click", () => {
        setToken(tokenInput.value.trim());
        updateDashboard();
      });
      clearTokenBtn.addEventListener("click", () => {
        tokenInput.value = "";
        setToken("");
        updateDashboard();
      });
    }

    function initVncControls() {
      vncPasswordInput.value = getVncPassword();
      saveVncBtn.addEventListener("click", () => {
        setVncPassword(vncPasswordInput.value);
        if (vncNeedsCredentials && rfbInstance) {
          const password = getVncPassword();
          if (password) {
            rfbInstance.sendCredentials({ password });
            setBadge(badgeVnc, "sending password…", "warn");
            vncNeedsCredentials = false;
            return;
          }
        }
        restartVnc();
      });
      clearVncBtn.addEventListener("click", () => {
        vncPasswordInput.value = "";
        setVncPassword("");
        vncNeedsCredentials = false;
      });
    }

    function initActions() {
      screenshotBtn.addEventListener("click", () => takeScreenshot({ download: false }));
      screenshotDownloadBtn.addEventListener("click", () => takeScreenshot({ download: true }));
      recordStartBtn.addEventListener("click", () => postRecordingAction("start"));
      recordPauseBtn.addEventListener("click", () => postRecordingAction("pause"));
      recordResumeBtn.addEventListener("click", () => postRecordingAction("resume"));
      recordStopBtn.addEventListener("click", () => postRecordingAction("stop"));
      shutdownBtn.addEventListener("click", () => requestShutdown(false));
      powerOffBtn.addEventListener("click", () => requestShutdown(true));
      resumePollingBtn.addEventListener("click", () => {
        const reason = sessionEndedReason;
        pollStopped = false;
        pollMode = "backoff";
        backoffIndex = 0;
        backoffElapsedMs = 0;
        if (reason === "vnc") {
          restartVnc();
        }
        logMessage("info", "Resuming polling...");
        scheduleNextPoll(BASE_BACKOFF_MS);
      });
      closeTabBtn.addEventListener("click", () => {
        attemptCloseTab();
      });
    }

    function initLogControls() {
      if (!logClearBtn || !logEntries || !logConsole || !logToggleBtn) {
        return;
      }
      logClearBtn.addEventListener("click", () => {
        logEntries.innerHTML = "";
        loggedEvents.clear();
        logMessage("info", "Log cleared.");
      });
      const logKey = "winebot_log_collapsed";
      const logSaved = localStorage.getItem(logKey);
      if (logSaved === "collapsed") {
        logConsole.classList.add("collapsed");
        logToggleBtn.setAttribute("aria-expanded", "false");
      }
      logToggleBtn.addEventListener("click", () => {
        const collapsed = logConsole.classList.toggle("collapsed");
        logToggleBtn.setAttribute("aria-expanded", collapsed ? "false" : "true");
        localStorage.setItem(logKey, collapsed ? "collapsed" : "expanded");
      });
      logMessage("info", "Dashboard loaded.");
    }

    function initCollapsibles() {
      const sections = document.querySelectorAll(".panel-section[data-collapsible]");
      const forcedCollapsed = new Set(["configuration", "api console"]);
      sections.forEach((section) => {
        const toggle = section.querySelector(".section-toggle");
        const title = section.querySelector(".section-title span");
        if (!toggle || !title) {
          return;
        }
        const titleText = title.textContent.trim().toLowerCase();
        const key = `winebot_panel_${titleText.replace(/\\s+/g, "_")}`;
        const saved = localStorage.getItem(key);
        const shouldForceCollapse = forcedCollapsed.has(titleText);
        if (shouldForceCollapse || saved === "collapsed") {
          section.classList.add("collapsed");
          toggle.setAttribute("aria-expanded", "false");
        }
        toggle.addEventListener("click", () => {
          const collapsed = section.classList.toggle("collapsed");
          toggle.setAttribute("aria-expanded", collapsed ? "false" : "true");
          if (shouldForceCollapse) {
            localStorage.setItem(key, "collapsed");
          } else {
            localStorage.setItem(key, collapsed ? "collapsed" : "expanded");
          }
        });
      });
    }

    const API_TEMPLATES = {
      health: { method: "GET", path: "/health", body: "" },
      sessions: { method: "GET", path: "/sessions", body: "" },
      suspend: { method: "POST", path: "/sessions/suspend", body: JSON.stringify({ shutdown_wine: true, stop_recording: true }, null, 2) },
      resume: { method: "POST", path: "/sessions/resume", body: JSON.stringify({ restart_wine: true, stop_recording: true }, null, 2) },
      "record-start": { method: "POST", path: "/recording/start", body: JSON.stringify({ new_session: false }, null, 2) },
      "record-stop": { method: "POST", path: "/recording/stop", body: "" },
      lifecycle: { method: "GET", path: "/lifecycle/status", body: "" },
      shutdown: { method: "POST", path: "/lifecycle/shutdown", body: "" },
      windows: { method: "GET", path: "/windows", body: "" },
      apps: { method: "GET", path: "/apps", body: "" },
      inspect: { method: "POST", path: "/inspect/window", body: JSON.stringify({ list_only: true }, null, 2) }
    };

    function initApiConsole() {
      apiPathInput.value = "/health";
      apiSendBtn.addEventListener("click", () => sendApiConsole(false));
      apiSendForceBtn.addEventListener("click", () => sendApiConsole(true));
      apiTemplateButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const template = API_TEMPLATES[button.dataset.apiTemplate];
          if (!template) {
            return;
          }
          apiMethodSelect.value = template.method;
          apiPathInput.value = template.path;
          apiBodyInput.value = template.body || "";
        });
      });
    }

    async function initVnc() {
      badgeVnc.textContent = "connecting...";
      try {
        const mod = await import("./core/rfb.js");
        resetVncCanvas();
        rfbInstance = new mod.default(vncContainer, "ws://localhost:6080");
        rfbInstance.viewOnly = false;
        rfbInstance.scaleViewport = true;
        rfbInstance.resizeSession = true;
        rfbInstance.addEventListener("connect", () => {
          setBadge(badgeVnc, "connected", "ok");
          vncConnected = true;
          if (typeof rfbInstance.focus === "function") {
            rfbInstance.focus();
          }
          logMessage("info", "Live session connected.");
          if (sessionEndedReason === "vnc") {
            exitBackoff("vnc");
          }
        });
        rfbInstance.addEventListener("disconnect", () => {
          setBadge(badgeVnc, "disconnected", "error");
          vncConnected = false;
          logMessage("warn", "Live session disconnected.");
          enterBackoff("vnc", "Live session disconnected", "noVNC connection lost. Waiting for the live session to reconnect.");
        });
        rfbInstance.addEventListener("credentialsrequired", () => {
          const password = getVncPassword();
          vncNeedsCredentials = true;
          if (password) {
            rfbInstance.sendCredentials({ password });
            setBadge(badgeVnc, "sending password…", "warn");
            vncNeedsCredentials = false;
            logMessage("info", "VNC password sent.");
          } else {
            setBadge(badgeVnc, "password required", "warn");
            logMessage("warn", "VNC password required.");
          }
        });
      } catch (err) {
        setBadge(badgeVnc, "noVNC load failed", "error");
      }
    }

    function restartVnc() {
      try {
        if (rfbInstance) {
          rfbInstance.disconnect();
        }
      } catch (err) {
        // Ignore disconnect errors.
      }
      initVnc();
    }

    initTokenControls();
    initVncControls();
    initActions();
    initApiConsole();
    initLogControls();
    initCollapsibles();
    initVnc();

    runPoll();
  </script>
</body>
</html>
